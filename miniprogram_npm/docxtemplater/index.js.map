{"version":3,"sources":["docxtemplater.js","doc-utils.js","errors.js","utils.js","traits.js","module-wrapper.js","scope-manager.js","collect-content-types.js","modules/common.js","filetypes.js","lexer.js","xml-templater.js","xml-matcher.js","parser.js","prefix-matcher.js","render.js","postrender.js","resolve.js","join-uncorrupt.js","file-type-config.js","modules/loop.js","modules/space-preserve.js","modules/rawxml.js","modules/expand-pair-trait.js","mergesort.js","modules/render.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AFOA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AFOA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AIXA,ANkBA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AIXA,ANkBA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AIXA,ANkBA,ADGA,AENA,AGTA,ACHA,AFMA;AGRA,ANkBA,ADGA,AENA,AGTA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AGTA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AGTA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,AJYA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,AJYA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,AJYA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA;AGRA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA,AOrBA;AJaA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA,AOrBA;AJaA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA,AOrBA;AJaA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AOrBA,ACHA,ALeA,AGTA,AFMA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,APqBA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,APqBA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,APqBA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,ACHA,ARwBA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,ACHA,ARwBA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,ACHA,ARwBA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,ACHA,ACHA,AT2BA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,ACHA,ACHA,AT2BA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,ACHA,ACHA,AT2BA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,AGTA,AFMA,ACHA,AT2BA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,AGTA,AFMA,ACHA,AT2BA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,AGTA,AFMA,ACHA,AT2BA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,ALeA,AGTA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AQxBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AgBhDA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AgBhDA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AJaA,ANkBA,ADGA,AENA,AgBhDA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,APqBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,APqBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,APqBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,ACHA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,ACHA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,ACHA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,AYpCA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,Ae7CA,AHSA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,Ae7CA,AHSA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AFMA,Ae7CA,AHSA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,ADGA,ARwBA,ACHA,ACHA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AQxBA,ADGA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AENA,AENA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AIZA,AXiCA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AiBnDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AZoCA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AZoCA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AZoCA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AZoCA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AZoCA,APqBA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AENA,AGTA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AKfA,AnByDA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,Ad0CA,AFMA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AhBgDA,AOrBA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA,AT2BA;AV+BA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AavCA,AHSA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AENA,AQxBA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA,AU9BA;AnB0DA,ADGA,AU9BA;AT4BA,ADGA,AU9BA;AT4BA,ADGA,AU9BA;AT4BA,ADGA,AU9BA;AT4BA,ADGA,AU9BA;AT4BA,ADGA,AU9BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\r\n\r\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar DocUtils = require(\"./doc-utils\");\r\n\r\nDocUtils.traits = require(\"./traits\");\r\nDocUtils.moduleWrapper = require(\"./module-wrapper\");\r\n\r\nvar createScope = require(\"./scope-manager\");\r\n\r\nvar _require = require(\"./errors\"),\r\n    throwMultiError = _require.throwMultiError,\r\n    throwResolveBeforeCompile = _require.throwResolveBeforeCompile,\r\n    throwRenderInvalidTemplate = _require.throwRenderInvalidTemplate;\r\n\r\nvar collectContentTypes = require(\"./collect-content-types\");\r\n\r\nvar ctXML = \"[Content_Types].xml\";\r\n\r\nvar commonModule = require(\"./modules/common\");\r\n\r\nvar Lexer = require(\"./lexer\");\r\n\r\nvar defaults = DocUtils.defaults,\r\n    str2xml = DocUtils.str2xml,\r\n    xml2str = DocUtils.xml2str,\r\n    moduleWrapper = DocUtils.moduleWrapper,\r\n    utf8ToWord = DocUtils.utf8ToWord,\r\n    concatArrays = DocUtils.concatArrays,\r\n    unique = DocUtils.unique;\r\n\r\nvar _require2 = require(\"./errors\"),\r\n    XTInternalError = _require2.XTInternalError,\r\n    throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified,\r\n    throwFileTypeNotHandled = _require2.throwFileTypeNotHandled,\r\n    throwApiVersionError = _require2.throwApiVersionError;\r\n\r\nvar currentModuleApiVersion = [3, 25, 0];\r\n\r\nvar Docxtemplater = /*#__PURE__*/function () {\r\n  function Docxtemplater(zip) {\r\n    var _this = this;\r\n\r\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n        _ref$modules = _ref.modules,\r\n        modules = _ref$modules === void 0 ? [] : _ref$modules,\r\n        options = _objectWithoutProperties(_ref, [\"modules\"]);\r\n\r\n    _classCallCheck(this, Docxtemplater);\r\n\r\n    if (!Array.isArray(modules)) {\r\n      throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\r\n    }\r\n\r\n    this.scopeManagers = {};\r\n    this.compiled = {};\r\n    this.modules = [commonModule()];\r\n    this.setOptions(options);\r\n    modules.forEach(function (module) {\r\n      _this.attachModule(module);\r\n    });\r\n\r\n    if (arguments.length > 0) {\r\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\r\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\r\n      }\r\n\r\n      this.loadZip(zip); // remove the unsupported modules\r\n\r\n      this.modules = this.modules.filter(function (module) {\r\n        if (module.supportedFileTypes) {\r\n          if (!Array.isArray(module.supportedFileTypes)) {\r\n            throw new Error(\"The supportedFileTypes field of the module must be an array\");\r\n          }\r\n\r\n          var isSupportedModule = module.supportedFileTypes.indexOf(_this.fileType) !== -1;\r\n\r\n          if (!isSupportedModule) {\r\n            module.on(\"detached\");\r\n          }\r\n\r\n          return isSupportedModule;\r\n        }\r\n\r\n        return true;\r\n      });\r\n      this.compile();\r\n      this.v4Constructor = true;\r\n    }\r\n  }\r\n\r\n  _createClass(Docxtemplater, [{\r\n    key: \"getModuleApiVersion\",\r\n    value: function getModuleApiVersion() {\r\n      return currentModuleApiVersion.join(\".\");\r\n    }\r\n  }, {\r\n    key: \"verifyApiVersion\",\r\n    value: function verifyApiVersion(neededVersion) {\r\n      neededVersion = neededVersion.split(\".\").map(function (i) {\r\n        return parseInt(i, 10);\r\n      });\r\n\r\n      if (neededVersion.length !== 3) {\r\n        throwApiVersionError(\"neededVersion is not a valid version\", {\r\n          neededVersion: neededVersion,\r\n          explanation: \"the neededVersion must be an array of length 3\"\r\n        });\r\n      }\r\n\r\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\r\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\r\n          neededVersion: neededVersion,\r\n          currentModuleApiVersion: currentModuleApiVersion,\r\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\r\n        });\r\n      }\r\n\r\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\r\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\r\n          neededVersion: neededVersion,\r\n          currentModuleApiVersion: currentModuleApiVersion,\r\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\r\n        });\r\n      }\r\n\r\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\r\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\r\n          neededVersion: neededVersion,\r\n          currentModuleApiVersion: currentModuleApiVersion,\r\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\r\n        });\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }, {\r\n    key: \"setModules\",\r\n    value: function setModules(obj) {\r\n      this.modules.forEach(function (module) {\r\n        module.set(obj);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"sendEvent\",\r\n    value: function sendEvent(eventName) {\r\n      this.modules.forEach(function (module) {\r\n        module.on(eventName);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"attachModule\",\r\n    value: function attachModule(module) {\r\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n      if (this.v4Constructor) {\r\n        throw new Error(\"attachModule() should not be called manually when using the v4 constructor\");\r\n      }\r\n\r\n      if (module.requiredAPIVersion) {\r\n        this.verifyApiVersion(module.requiredAPIVersion);\r\n      }\r\n\r\n      if (module.attached === true) {\r\n        throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". Maybe you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\r\n      }\r\n\r\n      module.attached = true;\r\n      var prefix = options.prefix;\r\n\r\n      if (prefix) {\r\n        module.prefix = prefix;\r\n      }\r\n\r\n      var wrappedModule = moduleWrapper(module);\r\n      this.modules.push(wrappedModule);\r\n      wrappedModule.on(\"attached\");\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"setOptions\",\r\n    value: function setOptions(options) {\r\n      var _this2 = this;\r\n\r\n      if (this.v4Constructor) {\r\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\r\n      }\r\n\r\n      if (!options) {\r\n        throw new Error(\"setOptions should be called with an object as first parameter\");\r\n      }\r\n\r\n      if (options.delimiters) {\r\n        options.delimiters.start = utf8ToWord(options.delimiters.start);\r\n        options.delimiters.end = utf8ToWord(options.delimiters.end);\r\n      }\r\n\r\n      this.options = {};\r\n      Object.keys(defaults).forEach(function (key) {\r\n        var defaultValue = defaults[key];\r\n        _this2.options[key] = options[key] != null ? options[key] : defaultValue;\r\n        _this2[key] = _this2.options[key];\r\n      });\r\n\r\n      if (this.zip) {\r\n        this.updateFileTypeConfig();\r\n      }\r\n\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"loadZip\",\r\n    value: function loadZip(zip) {\r\n      if (zip.loadAsync) {\r\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\r\n      }\r\n\r\n      this.zip = zip;\r\n      this.updateFileTypeConfig();\r\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\r\n        return moduleFunction();\r\n      }), this.modules]);\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"compileFile\",\r\n    value: function compileFile(fileName) {\r\n      this.compiled[fileName].parse();\r\n    }\r\n  }, {\r\n    key: \"precompileFile\",\r\n    value: function precompileFile(fileName) {\r\n      var currentFile = this.createTemplateClass(fileName);\r\n      currentFile.preparse();\r\n      this.compiled[fileName] = currentFile;\r\n    }\r\n  }, {\r\n    key: \"getScopeManager\",\r\n    value: function getScopeManager(to, currentFile, tags) {\r\n      if (!this.scopeManagers[to]) {\r\n        this.scopeManagers[to] = createScope({\r\n          tags: tags || {},\r\n          parser: this.parser,\r\n          cachedParsers: currentFile.cachedParsers\r\n        });\r\n      }\r\n\r\n      return this.scopeManagers[to];\r\n    }\r\n  }, {\r\n    key: \"resolveData\",\r\n    value: function resolveData(data) {\r\n      var _this3 = this;\r\n\r\n      var errors = [];\r\n\r\n      if (!Object.keys(this.compiled).length) {\r\n        throwResolveBeforeCompile();\r\n      }\r\n\r\n      return Promise.resolve(data).then(function (data) {\r\n        _this3.setData(data);\r\n\r\n        _this3.setModules({\r\n          data: _this3.data,\r\n          Lexer: Lexer\r\n        });\r\n\r\n        _this3.mapper = _this3.modules.reduce(function (value, module) {\r\n          return module.getRenderedMap(value);\r\n        }, {});\r\n        return Promise.all(Object.keys(_this3.mapper).map(function (to) {\r\n          var _this3$mapper$to = _this3.mapper[to],\r\n              from = _this3$mapper$to.from,\r\n              data = _this3$mapper$to.data;\r\n          return Promise.resolve(data).then(function (data) {\r\n            var currentFile = _this3.compiled[from];\r\n            currentFile.filePath = to;\r\n            currentFile.scopeManager = _this3.getScopeManager(to, currentFile, data);\r\n            currentFile.scopeManager.resolved = [];\r\n            return currentFile.resolveTags(data).then(function (result) {\r\n              currentFile.scopeManager.finishedResolving = true;\r\n              return result;\r\n            }, function (errs) {\r\n              errors = errors.concat(errs);\r\n            });\r\n          });\r\n        })).then(function (resolved) {\r\n          if (errors.length !== 0) {\r\n            throwMultiError(errors);\r\n          }\r\n\r\n          return concatArrays(resolved);\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: \"compile\",\r\n    value: function compile() {\r\n      var _this4 = this;\r\n\r\n      if (Object.keys(this.compiled).length) {\r\n        return this;\r\n      }\r\n\r\n      this.options = this.modules.reduce(function (options, module) {\r\n        return module.optionsTransformer(options, _this4);\r\n      }, this.options);\r\n      this.options.xmlFileNames = unique(this.options.xmlFileNames);\r\n      this.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {\r\n        var content = _this4.zip.files[fileName].asText();\r\n\r\n        xmlDocuments[fileName] = str2xml(content);\r\n        return xmlDocuments;\r\n      }, {});\r\n      this.setModules({\r\n        zip: this.zip,\r\n        xmlDocuments: this.xmlDocuments\r\n      });\r\n      this.getTemplatedFiles();\r\n      this.setModules({\r\n        compiled: this.compiled\r\n      }); // Loop inside all templatedFiles (ie xml files with content).\r\n      // Sometimes they don't exist (footer.xml for example)\r\n\r\n      this.templatedFiles.forEach(function (fileName) {\r\n        if (_this4.zip.files[fileName] != null) {\r\n          _this4.precompileFile(fileName);\r\n        }\r\n      });\r\n      this.templatedFiles.forEach(function (fileName) {\r\n        if (_this4.zip.files[fileName] != null) {\r\n          _this4.compileFile(fileName);\r\n        }\r\n      });\r\n      verifyErrors(this);\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"updateFileTypeConfig\",\r\n    value: function updateFileTypeConfig() {\r\n      var _this5 = this;\r\n\r\n      var fileType;\r\n\r\n      if (this.zip.files.mimetype) {\r\n        fileType = \"odt\";\r\n      }\r\n\r\n      var contentTypes = this.zip.files[ctXML];\r\n      this.targets = [];\r\n      var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\r\n      var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\r\n      var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\r\n\r\n      if (contentTypeXml) {\r\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\r\n        this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\r\n        this.setModules({\r\n          contentTypes: this.contentTypes,\r\n          invertedContentTypes: this.invertedContentTypes\r\n        });\r\n      }\r\n\r\n      this.modules.forEach(function (module) {\r\n        fileType = module.getFileType({\r\n          zip: _this5.zip,\r\n          contentTypes: contentTypes,\r\n          contentTypeXml: contentTypeXml,\r\n          overrides: overrides,\r\n          defaults: defaults,\r\n          doc: _this5\r\n        }) || fileType;\r\n      });\r\n\r\n      if (fileType === \"odt\") {\r\n        throwFileTypeNotHandled(fileType);\r\n      }\r\n\r\n      if (!fileType) {\r\n        throwFileTypeNotIdentified();\r\n      }\r\n\r\n      this.fileType = fileType;\r\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType]();\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"render\",\r\n    value: function render() {\r\n      var _this6 = this;\r\n\r\n      this.compile();\r\n\r\n      if (this.errors.length > 0) {\r\n        throwRenderInvalidTemplate();\r\n      }\r\n\r\n      this.setModules({\r\n        data: this.data,\r\n        Lexer: Lexer\r\n      });\r\n      this.mapper = this.modules.reduce(function (value, module) {\r\n        return module.getRenderedMap(value);\r\n      }, {});\r\n      this.fileTypeConfig.tagsXmlLexedArray = unique(this.fileTypeConfig.tagsXmlLexedArray);\r\n      this.fileTypeConfig.tagsXmlTextArray = unique(this.fileTypeConfig.tagsXmlTextArray);\r\n      Object.keys(this.mapper).forEach(function (to) {\r\n        var _this6$mapper$to = _this6.mapper[to],\r\n            from = _this6$mapper$to.from,\r\n            data = _this6$mapper$to.data;\r\n        var currentFile = _this6.compiled[from];\r\n        currentFile.setTags(data);\r\n        currentFile.scopeManager = _this6.getScopeManager(to, currentFile, data);\r\n        currentFile.render(to);\r\n\r\n        _this6.zip.file(to, currentFile.content, {\r\n          createFolders: true\r\n        });\r\n      });\r\n      verifyErrors(this);\r\n      this.sendEvent(\"syncing-zip\");\r\n      this.syncZip();\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"syncZip\",\r\n    value: function syncZip() {\r\n      var _this7 = this;\r\n\r\n      Object.keys(this.xmlDocuments).forEach(function (fileName) {\r\n        _this7.zip.remove(fileName);\r\n\r\n        var content = xml2str(_this7.xmlDocuments[fileName]);\r\n        return _this7.zip.file(fileName, content, {\r\n          createFolders: true\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: \"setData\",\r\n    value: function setData(data) {\r\n      this.data = data;\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"getZip\",\r\n    value: function getZip() {\r\n      return this.zip;\r\n    }\r\n  }, {\r\n    key: \"createTemplateClass\",\r\n    value: function createTemplateClass(path) {\r\n      var content = this.zip.files[path].asText();\r\n      return this.createTemplateClassFromContent(content, path);\r\n    }\r\n  }, {\r\n    key: \"createTemplateClassFromContent\",\r\n    value: function createTemplateClassFromContent(content, filePath) {\r\n      var _this8 = this;\r\n\r\n      var xmltOptions = {\r\n        filePath: filePath,\r\n        contentType: this.filesContentTypes[filePath]\r\n      };\r\n      Object.keys(defaults).concat([\"filesContentTypes\", \"fileTypeConfig\", \"modules\"]).forEach(function (key) {\r\n        xmltOptions[key] = _this8[key];\r\n      });\r\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\r\n    }\r\n  }, {\r\n    key: \"getFullText\",\r\n    value: function getFullText(path) {\r\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\r\n    }\r\n  }, {\r\n    key: \"getTemplatedFiles\",\r\n    value: function getTemplatedFiles() {\r\n      var _this9 = this;\r\n\r\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\r\n      this.targets.forEach(function (target) {\r\n        _this9.templatedFiles.push(target);\r\n      });\r\n      return this.templatedFiles;\r\n    }\r\n  }]);\r\n\r\n  return Docxtemplater;\r\n}();\r\n\r\nfunction verifyErrors(doc) {\r\n  var compiled = doc.compiled;\r\n  var allErrors = [];\r\n  Object.keys(compiled).forEach(function (name) {\r\n    var templatePart = compiled[name];\r\n    allErrors = concatArrays([allErrors, templatePart.allErrors]);\r\n  });\r\n  doc.errors = allErrors;\r\n\r\n  if (allErrors.length !== 0) {\r\n    throwMultiError(allErrors);\r\n  }\r\n}\r\n\r\nDocxtemplater.DocUtils = DocUtils;\r\nDocxtemplater.Errors = require(\"./errors\");\r\nDocxtemplater.XmlTemplater = require(\"./xml-templater\");\r\nDocxtemplater.FileTypeConfig = require(\"./file-type-config\");\r\nDocxtemplater.XmlMatcher = require(\"./xml-matcher\");\r\nmodule.exports = Docxtemplater;","\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nvar _require = require(\"xmldom\"),\r\n    DOMParser = _require.DOMParser,\r\n    XMLSerializer = _require.XMLSerializer;\r\n\r\nvar _require2 = require(\"./errors\"),\r\n    throwXmlTagNotFound = _require2.throwXmlTagNotFound;\r\n\r\nvar _require3 = require(\"./utils\"),\r\n    last = _require3.last,\r\n    first = _require3.first;\r\n\r\nfunction parser(tag) {\r\n  return {\r\n    get: function get(scope) {\r\n      if (tag === \".\") {\r\n        return scope;\r\n      }\r\n\r\n      return scope[tag];\r\n    }\r\n  };\r\n}\r\n\r\nfunction getNearestLeftIndex(parsed, elements, index) {\r\n  for (var i = index; i >= 0; i--) {\r\n    var part = parsed[i];\r\n\r\n    for (var j = 0, len = elements.length; j < len; j++) {\r\n      var element = elements[j];\r\n\r\n      if (isStarting(part.value, element)) {\r\n        return j;\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getNearestRightIndex(parsed, elements, index) {\r\n  for (var i = index, l = parsed.length; i < l; i++) {\r\n    var part = parsed[i];\r\n\r\n    for (var j = 0, len = elements.length; j < len; j++) {\r\n      var element = elements[j];\r\n\r\n      if (isEnding(part.value, element)) {\r\n        return j;\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction getNearestLeft(parsed, elements, index) {\r\n  var found = getNearestLeftIndex(parsed, elements, index);\r\n\r\n  if (found !== -1) {\r\n    return elements[found];\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getNearestRight(parsed, elements, index) {\r\n  var found = getNearestRightIndex(parsed, elements, index);\r\n\r\n  if (found !== -1) {\r\n    return elements[found];\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction buildNearestCache(postparsed, tags) {\r\n  return postparsed.reduce(function (cached, part, i) {\r\n    if (part.type === \"tag\" && tags.indexOf(part.tag) !== -1) {\r\n      cached.push({\r\n        i: i,\r\n        part: part\r\n      });\r\n    }\r\n\r\n    return cached;\r\n  }, []);\r\n}\r\n\r\nfunction getNearestLeftIndexWithCache(index, cache) {\r\n  if (cache.length === 0) {\r\n    return -1;\r\n  }\r\n\r\n  for (var i = 0, len = cache.length; i < len; i++) {\r\n    var current = cache[i];\r\n    var next = cache[i + 1];\r\n\r\n    if (current.i < index && (!next || index < next.i) && current.part.position === \"start\") {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction getNearestLeftWithCache(index, cache) {\r\n  var found = getNearestLeftIndexWithCache(index, cache);\r\n\r\n  if (found !== -1) {\r\n    return cache[found].part.tag;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getNearestRightIndexWithCache(index, cache) {\r\n  if (cache.length === 0) {\r\n    return -1;\r\n  }\r\n\r\n  for (var i = 0, len = cache.length; i < len; i++) {\r\n    var current = cache[i];\r\n    var _last = cache[i - 1];\r\n\r\n    if (index < current.i && (!_last || _last.i < index) && current.part.position === \"end\") {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction getNearestRightWithCache(index, cache) {\r\n  var found = getNearestRightIndexWithCache(index, cache);\r\n\r\n  if (found !== -1) {\r\n    return cache[found].part.tag;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction endsWith(str, suffix) {\r\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n}\r\n\r\nfunction startsWith(str, prefix) {\r\n  return str.substring(0, prefix.length) === prefix;\r\n}\r\n\r\nfunction unique(arr) {\r\n  var hash = {},\r\n      result = [];\r\n\r\n  for (var i = 0, l = arr.length; i < l; ++i) {\r\n    if (!hash.hasOwnProperty(arr[i])) {\r\n      hash[arr[i]] = true;\r\n      result.push(arr[i]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction chunkBy(parsed, f) {\r\n  return parsed.reduce(function (chunks, p) {\r\n    var currentChunk = last(chunks);\r\n    var res = f(p);\r\n\r\n    if (currentChunk.length === 0) {\r\n      currentChunk.push(p);\r\n      return chunks;\r\n    }\r\n\r\n    if (res === \"start\") {\r\n      chunks.push([p]);\r\n    } else if (res === \"end\") {\r\n      currentChunk.push(p);\r\n      chunks.push([]);\r\n    } else {\r\n      currentChunk.push(p);\r\n    }\r\n\r\n    return chunks;\r\n  }, [[]]).filter(function (p) {\r\n    return p.length > 0;\r\n  });\r\n}\r\n\r\nvar defaults = {\r\n  paragraphLoop: false,\r\n  nullGetter: function nullGetter(part) {\r\n    if (!part.module) {\r\n      return \"undefined\";\r\n    }\r\n\r\n    if (part.module === \"rawxml\") {\r\n      return \"\";\r\n    }\r\n\r\n    return \"\";\r\n  },\r\n  xmlFileNames: [],\r\n  parser: parser,\r\n  linebreaks: false,\r\n  fileTypeConfig: null,\r\n  delimiters: {\r\n    start: \"{\",\r\n    end: \"}\"\r\n  }\r\n};\r\n\r\nfunction mergeObjects() {\r\n  var resObj = {};\r\n  var obj, keys;\r\n\r\n  for (var i = 0; i < arguments.length; i += 1) {\r\n    obj = arguments[i];\r\n    keys = Object.keys(obj);\r\n\r\n    for (var j = 0; j < keys.length; j += 1) {\r\n      resObj[keys[j]] = obj[keys[j]];\r\n    }\r\n  }\r\n\r\n  return resObj;\r\n}\r\n\r\nfunction xml2str(xmlNode) {\r\n  var a = new XMLSerializer();\r\n  return a.serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\r\n}\r\n\r\nfunction str2xml(str) {\r\n  if (str.charCodeAt(0) === 65279) {\r\n    // BOM sequence\r\n    str = str.substr(1);\r\n  }\r\n\r\n  var parser = new DOMParser();\r\n  return parser.parseFromString(str, \"text/xml\");\r\n}\r\n\r\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\r\n\r\nfunction escapeRegExp(str) {\r\n  // to be able to use a string as a regex\r\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\nvar charMapRegexes = charMap.map(function (_ref) {\r\n  var _ref2 = _slicedToArray(_ref, 2),\r\n      endChar = _ref2[0],\r\n      startChar = _ref2[1];\r\n\r\n  return {\r\n    rstart: new RegExp(escapeRegExp(startChar), \"g\"),\r\n    rend: new RegExp(escapeRegExp(endChar), \"g\"),\r\n    start: startChar,\r\n    end: endChar\r\n  };\r\n});\r\n\r\nfunction wordToUtf8(string) {\r\n  var r;\r\n\r\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\r\n    r = charMapRegexes[i];\r\n    string = string.replace(r.rstart, r.end);\r\n  }\r\n\r\n  return string;\r\n}\r\n\r\nfunction utf8ToWord(string) {\r\n  if (typeof string !== \"string\") {\r\n    string = string.toString();\r\n  }\r\n\r\n  var r;\r\n\r\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\r\n    r = charMapRegexes[i];\r\n    string = string.replace(r.rend, r.start);\r\n  }\r\n\r\n  return string;\r\n} // This function is written with for loops for performance\r\n\r\n\r\nfunction concatArrays(arrays) {\r\n  var result = [];\r\n\r\n  for (var i = 0; i < arrays.length; i++) {\r\n    var array = arrays[i];\r\n\r\n    for (var j = 0, len = array.length; j < len; j++) {\r\n      result.push(array[j]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\r\n\r\nfunction convertSpaces(s) {\r\n  return s.replace(spaceRegexp, \" \");\r\n}\r\n\r\nfunction pregMatchAll(regex, content) {\r\n  /* regex is a string, content is the content. It returns an array of all matches with their offset, for example:\r\n  \t regex=la\r\n  \t content=lolalolilala\r\n  returns: [{array: {0: 'la'},offset: 2},{array: {0: 'la'},offset: 8},{array: {0: 'la'} ,offset: 10}]\r\n  */\r\n  var matchArray = [];\r\n  var match;\r\n\r\n  while ((match = regex.exec(content)) != null) {\r\n    matchArray.push({\r\n      array: match,\r\n      offset: match.index\r\n    });\r\n  }\r\n\r\n  return matchArray;\r\n}\r\n\r\nfunction isEnding(value, element) {\r\n  return value === \"</\" + element + \">\";\r\n}\r\n\r\nfunction isStarting(value, element) {\r\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \"].indexOf(value[element.length + 1]) !== -1;\r\n}\r\n\r\nfunction getRight(parsed, element, index) {\r\n  var val = getRightOrNull(parsed, element, index);\r\n\r\n  if (val !== null) {\r\n    return val;\r\n  }\r\n\r\n  throwXmlTagNotFound({\r\n    position: \"right\",\r\n    element: element,\r\n    parsed: parsed,\r\n    index: index\r\n  });\r\n}\r\n\r\nfunction getRightOrNull(parsed, elements, index) {\r\n  if (typeof elements === \"string\") {\r\n    elements = [elements];\r\n  }\r\n\r\n  var level = 1;\r\n\r\n  for (var i = index, l = parsed.length; i < l; i++) {\r\n    var part = parsed[i];\r\n\r\n    for (var j = 0, len = elements.length; j < len; j++) {\r\n      var element = elements[j];\r\n\r\n      if (isEnding(part.value, element)) {\r\n        level--;\r\n      }\r\n\r\n      if (isStarting(part.value, element)) {\r\n        level++;\r\n      }\r\n\r\n      if (level === 0) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getLeft(parsed, element, index) {\r\n  var val = getLeftOrNull(parsed, element, index);\r\n\r\n  if (val !== null) {\r\n    return val;\r\n  }\r\n\r\n  throwXmlTagNotFound({\r\n    position: \"left\",\r\n    element: element,\r\n    parsed: parsed,\r\n    index: index\r\n  });\r\n}\r\n\r\nfunction getLeftOrNull(parsed, elements, index) {\r\n  if (typeof elements === \"string\") {\r\n    elements = [elements];\r\n  }\r\n\r\n  var level = 1;\r\n\r\n  for (var i = index; i >= 0; i--) {\r\n    var part = parsed[i];\r\n\r\n    for (var j = 0, len = elements.length; j < len; j++) {\r\n      var element = elements[j];\r\n\r\n      if (isStarting(part.value, element)) {\r\n        level--;\r\n      }\r\n\r\n      if (isEnding(part.value, element)) {\r\n        level++;\r\n      }\r\n\r\n      if (level === 0) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction isTagStart(tagType, _ref3) {\r\n  var type = _ref3.type,\r\n      tag = _ref3.tag,\r\n      position = _ref3.position;\r\n  return type === \"tag\" && tag === tagType && position === \"start\";\r\n}\r\n\r\nfunction isTagEnd(tagType, _ref4) {\r\n  var type = _ref4.type,\r\n      tag = _ref4.tag,\r\n      position = _ref4.position;\r\n  return type === \"tag\" && tag === tagType && position === \"end\";\r\n}\r\n\r\nfunction isParagraphStart(options) {\r\n  return isTagStart(\"w:p\", options) || isTagStart(\"a:p\", options);\r\n}\r\n\r\nfunction isParagraphEnd(options) {\r\n  return isTagEnd(\"w:p\", options) || isTagEnd(\"a:p\", options);\r\n}\r\n\r\nfunction isTextStart(part) {\r\n  return part.type === \"tag\" && part.position === \"start\" && part.text;\r\n}\r\n\r\nfunction isTextEnd(part) {\r\n  return part.type === \"tag\" && part.position === \"end\" && part.text;\r\n}\r\n\r\nfunction isContent(p) {\r\n  return p.type === \"placeholder\" || p.type === \"content\" && p.position === \"insidetag\";\r\n}\r\n\r\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/; // 00    NUL '\\0' (null character)\r\n// 01    SOH (start of heading)\r\n// 02    STX (start of text)\r\n// 03    ETX (end of text)\r\n// 04    EOT (end of transmission)\r\n// 05    ENQ (enquiry)\r\n// 06    ACK (acknowledge)\r\n// 07    BEL '\\a' (bell)\r\n// 08    BS  '\\b' (backspace)\r\n// 0B    VT  '\\v' (vertical tab)\r\n// 0C    FF  '\\f' (form feed)\r\n// 0E    SO  (shift out)\r\n// 0F    SI  (shift in)\r\n// 10    DLE (data link escape)\r\n// 11    DC1 (device control 1)\r\n// 12    DC2 (device control 2)\r\n// 13    DC3 (device control 3)\r\n// 14    DC4 (device control 4)\r\n// 15    NAK (negative ack.)\r\n// 16    SYN (synchronous idle)\r\n// 17    ETB (end of trans. blk)\r\n// 18    CAN (cancel)\r\n// 19    EM  (end of medium)\r\n// 1A    SUB (substitute)\r\n// 1B    ESC (escape)\r\n// 1C    FS  (file separator)\r\n// 1D    GS  (group separator)\r\n// 1E    RS  (record separator)\r\n// 1F    US  (unit separator)\r\n\r\nfunction hasCorruptCharacters(string) {\r\n  return corruptCharacters.test(string);\r\n}\r\n\r\nfunction invertMap(map) {\r\n  return Object.keys(map).reduce(function (invertedMap, key) {\r\n    var value = map[key];\r\n    invertedMap[value] = invertedMap[value] || [];\r\n    invertedMap[value].push(key);\r\n    return invertedMap;\r\n  }, {});\r\n}\r\n\r\nmodule.exports = {\r\n  endsWith: endsWith,\r\n  startsWith: startsWith,\r\n  getNearestLeft: getNearestLeft,\r\n  getNearestRight: getNearestRight,\r\n  getNearestLeftWithCache: getNearestLeftWithCache,\r\n  getNearestRightWithCache: getNearestRightWithCache,\r\n  getNearestLeftIndex: getNearestLeftIndex,\r\n  getNearestRightIndex: getNearestRightIndex,\r\n  getNearestLeftIndexWithCache: getNearestLeftIndexWithCache,\r\n  getNearestRightIndexWithCache: getNearestRightIndexWithCache,\r\n  buildNearestCache: buildNearestCache,\r\n  isContent: isContent,\r\n  isParagraphStart: isParagraphStart,\r\n  isParagraphEnd: isParagraphEnd,\r\n  isTagStart: isTagStart,\r\n  isTagEnd: isTagEnd,\r\n  isTextStart: isTextStart,\r\n  isTextEnd: isTextEnd,\r\n  unique: unique,\r\n  chunkBy: chunkBy,\r\n  last: last,\r\n  first: first,\r\n  mergeObjects: mergeObjects,\r\n  xml2str: xml2str,\r\n  str2xml: str2xml,\r\n  getRightOrNull: getRightOrNull,\r\n  getRight: getRight,\r\n  getLeftOrNull: getLeftOrNull,\r\n  getLeft: getLeft,\r\n  pregMatchAll: pregMatchAll,\r\n  convertSpaces: convertSpaces,\r\n  escapeRegExp: escapeRegExp,\r\n  charMapRegexes: charMapRegexes,\r\n  hasCorruptCharacters: hasCorruptCharacters,\r\n  defaults: defaults,\r\n  wordToUtf8: wordToUtf8,\r\n  utf8ToWord: utf8ToWord,\r\n  concatArrays: concatArrays,\r\n  invertMap: invertMap,\r\n  charMap: charMap\r\n};","\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nvar _require = require(\"./utils\"),\r\n    last = _require.last,\r\n    first = _require.first;\r\n\r\nfunction XTError(message) {\r\n  this.name = \"GenericError\";\r\n  this.message = message;\r\n  this.stack = new Error(message).stack;\r\n}\r\n\r\nXTError.prototype = Error.prototype;\r\n\r\nfunction XTTemplateError(message) {\r\n  this.name = \"TemplateError\";\r\n  this.message = message;\r\n  this.stack = new Error(message).stack;\r\n}\r\n\r\nXTTemplateError.prototype = new XTError();\r\n\r\nfunction XTRenderingError(message) {\r\n  this.name = \"RenderingError\";\r\n  this.message = message;\r\n  this.stack = new Error(message).stack;\r\n}\r\n\r\nXTRenderingError.prototype = new XTError();\r\n\r\nfunction XTScopeParserError(message) {\r\n  this.name = \"ScopeParserError\";\r\n  this.message = message;\r\n  this.stack = new Error(message).stack;\r\n}\r\n\r\nXTScopeParserError.prototype = new XTError();\r\n\r\nfunction XTInternalError(message) {\r\n  this.name = \"InternalError\";\r\n  this.properties = {\r\n    explanation: \"InternalError\"\r\n  };\r\n  this.message = message;\r\n  this.stack = new Error(message).stack;\r\n}\r\n\r\nXTInternalError.prototype = new XTError();\r\n\r\nfunction XTAPIVersionError(message) {\r\n  this.name = \"APIVersionError\";\r\n  this.properties = {\r\n    explanation: \"APIVersionError\"\r\n  };\r\n  this.message = message;\r\n  this.stack = new Error(message).stack;\r\n}\r\n\r\nXTAPIVersionError.prototype = new XTError();\r\n\r\nfunction throwApiVersionError(msg, properties) {\r\n  var err = new XTAPIVersionError(msg);\r\n  err.properties = _objectSpread({\r\n    id: \"api_version_error\"\r\n  }, properties);\r\n  throw err;\r\n}\r\n\r\nfunction throwMultiError(errors) {\r\n  var err = new XTTemplateError(\"Multi error\");\r\n  err.properties = {\r\n    errors: errors,\r\n    id: \"multi_error\",\r\n    explanation: \"The template has multiple errors\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction getUnopenedTagException(options) {\r\n  var err = new XTTemplateError(\"Unopened tag\");\r\n  err.properties = {\r\n    xtag: last(options.xtag.split(\" \")),\r\n    id: \"unopened_tag\",\r\n    context: options.xtag,\r\n    offset: options.offset,\r\n    lIndex: options.lIndex,\r\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getDuplicateOpenTagException(options) {\r\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\r\n  err.properties = {\r\n    xtag: first(options.xtag.split(\" \")),\r\n    id: \"duplicate_open_tag\",\r\n    context: options.xtag,\r\n    offset: options.offset,\r\n    lIndex: options.lIndex,\r\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getDuplicateCloseTagException(options) {\r\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\r\n  err.properties = {\r\n    xtag: first(options.xtag.split(\" \")),\r\n    id: \"duplicate_close_tag\",\r\n    context: options.xtag,\r\n    offset: options.offset,\r\n    lIndex: options.lIndex,\r\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getUnclosedTagException(options) {\r\n  var err = new XTTemplateError(\"Unclosed tag\");\r\n  err.properties = {\r\n    xtag: first(options.xtag.split(\" \")).substr(1),\r\n    id: \"unclosed_tag\",\r\n    context: options.xtag,\r\n    offset: options.offset,\r\n    lIndex: options.lIndex,\r\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction throwXmlTagNotFound(options) {\r\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\r\n  var part = options.parsed[options.index];\r\n  err.properties = {\r\n    id: \"no_xml_tag_found_at_\".concat(options.position),\r\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\r\n    offset: part.offset,\r\n    part: part,\r\n    parsed: options.parsed,\r\n    index: options.index,\r\n    element: options.element\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction getCorruptCharactersException(_ref) {\r\n  var tag = _ref.tag,\r\n      value = _ref.value,\r\n      offset = _ref.offset;\r\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\r\n  err.properties = {\r\n    id: \"invalid_xml_characters\",\r\n    xtag: tag,\r\n    value: value,\r\n    offset: offset,\r\n    explanation: \"There are some corrupt characters for the field ${tag}\"\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction throwContentMustBeString(type) {\r\n  var err = new XTInternalError(\"Content must be a string\");\r\n  err.properties.id = \"xmltemplater_content_must_be_string\";\r\n  err.properties.type = type;\r\n  throw err;\r\n}\r\n\r\nfunction throwExpandNotFound(options) {\r\n  var _options$part = options.part,\r\n      value = _options$part.value,\r\n      offset = _options$part.offset,\r\n      _options$id = options.id,\r\n      id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\r\n      _options$message = options.message,\r\n      message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\r\n  var part = options.part;\r\n  var _options$explanation = options.explanation,\r\n      explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\r\n\r\n  if (typeof explanation === \"function\") {\r\n    explanation = explanation(part);\r\n  }\r\n\r\n  var err = new XTTemplateError(message);\r\n  err.properties = {\r\n    id: id,\r\n    explanation: explanation,\r\n    rootError: options.rootError,\r\n    xtag: value,\r\n    offset: offset,\r\n    postparsed: options.postparsed,\r\n    expandTo: options.expandTo,\r\n    index: options.index\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\r\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\r\n  var tag = options.part.value;\r\n  err.properties = {\r\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\r\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\r\n    xtag: tag,\r\n    offset: options.part.offset,\r\n    paragraphParts: options.paragraphParts\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction getUnmatchedLoopException(part) {\r\n  var location = part.location,\r\n      offset = part.offset;\r\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\r\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\r\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\r\n  var tag = part.value;\r\n  err.properties = {\r\n    id: \"\".concat(t, \"_loop\"),\r\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\r\n    xtag: tag,\r\n    offset: offset\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getUnbalancedLoopException(pair, lastPair) {\r\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\r\n  var lastL = lastPair[0].part.value;\r\n  var lastR = lastPair[1].part.value;\r\n  var l = pair[0].part.value;\r\n  var r = pair[1].part.value;\r\n  err.properties = {\r\n    id: \"unbalanced_loop_tags\",\r\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\r\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\r\n    lastPair: {\r\n      left: lastPair[0].part.value,\r\n      right: lastPair[1].part.value\r\n    },\r\n    pair: {\r\n      left: pair[0].part.value,\r\n      right: pair[1].part.value\r\n    }\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getClosingTagNotMatchOpeningTag(_ref2) {\r\n  var tags = _ref2.tags;\r\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\r\n  err.properties = {\r\n    id: \"closing_tag_does_not_match_opening_tag\",\r\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\r\n    openingtag: first(tags).value,\r\n    offset: [first(tags).offset, last(tags).offset],\r\n    closingtag: last(tags).value\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getScopeCompilationError(_ref3) {\r\n  var tag = _ref3.tag,\r\n      rootError = _ref3.rootError,\r\n      offset = _ref3.offset;\r\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\r\n  err.properties = {\r\n    id: \"scopeparser_compilation_failed\",\r\n    offset: offset,\r\n    tag: tag,\r\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\r\n    rootError: rootError\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getScopeParserExecutionError(_ref4) {\r\n  var tag = _ref4.tag,\r\n      scope = _ref4.scope,\r\n      error = _ref4.error,\r\n      offset = _ref4.offset;\r\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\r\n  err.properties = {\r\n    id: \"scopeparser_execution_failed\",\r\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\r\n    scope: scope,\r\n    offset: offset,\r\n    tag: tag,\r\n    rootError: error\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction getLoopPositionProducesInvalidXMLError(_ref5) {\r\n  var tag = _ref5.tag,\r\n      offset = _ref5.offset;\r\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\r\n  err.properties = {\r\n    tag: tag,\r\n    id: \"loop_position_invalid\",\r\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\r\n    offset: offset\r\n  };\r\n  return err;\r\n}\r\n\r\nfunction throwUnimplementedTagType(part, index) {\r\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\r\n\r\n  if (part.module) {\r\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\r\n  }\r\n\r\n  var err = new XTTemplateError(errorMsg);\r\n  err.properties = {\r\n    part: part,\r\n    index: index,\r\n    id: \"unimplemented_tag_type\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwMalformedXml(part) {\r\n  var err = new XTInternalError(\"Malformed xml\");\r\n  err.properties = {\r\n    part: part,\r\n    id: \"malformed_xml\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwLocationInvalid(part) {\r\n  throw new XTInternalError(\"Location should be one of \\\"start\\\" or \\\"end\\\" (given : \".concat(part.location, \")\"));\r\n}\r\n\r\nfunction throwResolveBeforeCompile() {\r\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\r\n  err.properties = {\r\n    id: \"resolve_before_compile\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwRenderInvalidTemplate() {\r\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\r\n  err.properties = {\r\n    id: \"render_on_invalid_template\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwFileTypeNotIdentified() {\r\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ?\");\r\n  err.properties = {\r\n    id: \"filetype_not_identified\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwXmlInvalid(content, offset) {\r\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\r\n  err.properties = {\r\n    id: \"file_has_invalid_xml\",\r\n    content: content,\r\n    offset: offset,\r\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\r\n  };\r\n  throw err;\r\n}\r\n\r\nfunction throwFileTypeNotHandled(fileType) {\r\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\r\n  err.properties = {\r\n    id: \"filetype_not_handled\",\r\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\r\n    fileType: fileType\r\n  };\r\n  throw err;\r\n}\r\n\r\nmodule.exports = {\r\n  XTError: XTError,\r\n  XTTemplateError: XTTemplateError,\r\n  XTInternalError: XTInternalError,\r\n  XTScopeParserError: XTScopeParserError,\r\n  XTAPIVersionError: XTAPIVersionError,\r\n  // Remove this alias in v4\r\n  RenderingError: XTRenderingError,\r\n  XTRenderingError: XTRenderingError,\r\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\r\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\r\n  getScopeCompilationError: getScopeCompilationError,\r\n  getScopeParserExecutionError: getScopeParserExecutionError,\r\n  getUnclosedTagException: getUnclosedTagException,\r\n  getUnopenedTagException: getUnopenedTagException,\r\n  getUnmatchedLoopException: getUnmatchedLoopException,\r\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\r\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\r\n  getCorruptCharactersException: getCorruptCharactersException,\r\n  getUnbalancedLoopException: getUnbalancedLoopException,\r\n  throwApiVersionError: throwApiVersionError,\r\n  throwContentMustBeString: throwContentMustBeString,\r\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\r\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\r\n  throwLocationInvalid: throwLocationInvalid,\r\n  throwMalformedXml: throwMalformedXml,\r\n  throwMultiError: throwMultiError,\r\n  throwExpandNotFound: throwExpandNotFound,\r\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\r\n  throwUnimplementedTagType: throwUnimplementedTagType,\r\n  throwXmlTagNotFound: throwXmlTagNotFound,\r\n  throwXmlInvalid: throwXmlInvalid,\r\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\r\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate\r\n};","\r\n\r\nfunction last(a) {\r\n  return a[a.length - 1];\r\n}\r\n\r\nfunction first(a) {\r\n  return a[0];\r\n}\r\n\r\nmodule.exports = {\r\n  last: last,\r\n  first: first\r\n};","\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nvar _require = require(\"./doc-utils\"),\r\n    getRightOrNull = _require.getRightOrNull,\r\n    getRight = _require.getRight,\r\n    getLeft = _require.getLeft,\r\n    getLeftOrNull = _require.getLeftOrNull,\r\n    chunkBy = _require.chunkBy,\r\n    isTagStart = _require.isTagStart,\r\n    isTagEnd = _require.isTagEnd,\r\n    isContent = _require.isContent,\r\n    last = _require.last,\r\n    first = _require.first;\r\n\r\nvar _require2 = require(\"./errors\"),\r\n    XTTemplateError = _require2.XTTemplateError,\r\n    throwExpandNotFound = _require2.throwExpandNotFound,\r\n    getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\r\n\r\nfunction lastTagIsOpenTag(tags, tag) {\r\n  if (tags.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  var innerLastTag = last(tags).tag.substr(1);\r\n  var innerCurrentTag = tag.substr(2, tag.length - 3);\r\n  return innerLastTag.indexOf(innerCurrentTag) === 0;\r\n}\r\n\r\nfunction addTag(tags, tag) {\r\n  tags.push({\r\n    tag: tag\r\n  });\r\n  return tags;\r\n}\r\n\r\nfunction getListXmlElements(parts) {\r\n  /*\r\n  get the different closing and opening tags between two texts (doesn't take into account tags that are opened then closed (those that are closed then opened are returned)):\r\n  returns:[{\"tag\":\"</w:r>\",\"offset\":13},{\"tag\":\"</w:p>\",\"offset\":265},{\"tag\":\"</w:tc>\",\"offset\":271},{\"tag\":\"<w:tc>\",\"offset\":828},{\"tag\":\"<w:p>\",\"offset\":883},{\"tag\":\"<w:r>\",\"offset\":1483}]\r\n  */\r\n  var tags = parts.filter(function (part) {\r\n    return part.type === \"tag\";\r\n  });\r\n  var result = [];\r\n\r\n  for (var i = 0, tag; i < tags.length; i++) {\r\n    tag = tags[i].value; // closing tag\r\n\r\n    if (tag[1] === \"/\") {\r\n      if (lastTagIsOpenTag(result, tag)) {\r\n        result.pop();\r\n      } else {\r\n        result = addTag(result, tag);\r\n      }\r\n    } else if (tag[tag.length - 2] !== \"/\") {\r\n      result = addTag(result, tag);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction has(name, xmlElements) {\r\n  for (var i = 0; i < xmlElements.length; i++) {\r\n    var xmlElement = xmlElements[i];\r\n\r\n    if (xmlElement.tag.indexOf(\"<\".concat(name)) === 0) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getExpandToDefault(postparsed, pair, expandTags) {\r\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\r\n  var xmlElements = getListXmlElements(parts);\r\n  var closingTagCount = xmlElements.filter(function (xmlElement) {\r\n    return xmlElement.tag[1] === \"/\";\r\n  }).length;\r\n  var startingTagCount = xmlElements.filter(function (xmlElement) {\r\n    var tag = xmlElement.tag;\r\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\r\n  }).length;\r\n\r\n  if (closingTagCount !== startingTagCount) {\r\n    return {\r\n      error: getLoopPositionProducesInvalidXMLError({\r\n        tag: first(pair).part.value,\r\n        offset: [first(pair).part.offset, last(pair).part.offset]\r\n      })\r\n    };\r\n  }\r\n\r\n  var _loop = function _loop(i, len) {\r\n    var _expandTags$i = expandTags[i],\r\n        contains = _expandTags$i.contains,\r\n        expand = _expandTags$i.expand,\r\n        onlyTextInTag = _expandTags$i.onlyTextInTag;\r\n\r\n    if (has(contains, xmlElements)) {\r\n      if (onlyTextInTag) {\r\n        var left = getLeftOrNull(postparsed, contains, pair[0].offset);\r\n        var right = getRightOrNull(postparsed, contains, pair[1].offset);\r\n\r\n        if (left === null || right === null) {\r\n          return \"continue\";\r\n        }\r\n\r\n        var chunks = chunkBy(postparsed.slice(left, right), function (p) {\r\n          if (isTagStart(contains, p)) {\r\n            return \"start\";\r\n          }\r\n\r\n          if (isTagEnd(contains, p)) {\r\n            return \"end\";\r\n          }\r\n\r\n          return null;\r\n        });\r\n\r\n        if (chunks.length <= 2) {\r\n          return \"continue\";\r\n        }\r\n\r\n        var firstChunk = first(chunks);\r\n        var lastChunk = last(chunks);\r\n        var firstContent = firstChunk.filter(isContent);\r\n        var lastContent = lastChunk.filter(isContent);\r\n\r\n        if (firstContent.length !== 1 || lastContent.length !== 1) {\r\n          return \"continue\";\r\n        }\r\n      }\r\n\r\n      return {\r\n        v: {\r\n          value: expand\r\n        }\r\n      };\r\n    }\r\n  };\r\n\r\n  for (var i = 0, len = expandTags.length; i < len; i++) {\r\n    var _ret = _loop(i, len);\r\n\r\n    if (_ret === \"continue\") continue;\r\n    if (_typeof(_ret) === \"object\") return _ret.v;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction expandOne(part, index, postparsed, options) {\r\n  var expandTo = part.expandTo || options.expandTo;\r\n\r\n  if (!expandTo) {\r\n    return postparsed;\r\n  }\r\n\r\n  var right, left;\r\n\r\n  try {\r\n    left = getLeft(postparsed, expandTo, index);\r\n    right = getRight(postparsed, expandTo, index);\r\n  } catch (rootError) {\r\n    if (rootError instanceof XTTemplateError) {\r\n      throwExpandNotFound(_objectSpread({\r\n        part: part,\r\n        rootError: rootError,\r\n        postparsed: postparsed,\r\n        expandTo: expandTo,\r\n        index: index\r\n      }, options.error));\r\n    }\r\n\r\n    throw rootError;\r\n  }\r\n\r\n  var leftParts = postparsed.slice(left, index);\r\n  var rightParts = postparsed.slice(index + 1, right + 1);\r\n  var inner = options.getInner({\r\n    postparse: options.postparse,\r\n    index: index,\r\n    part: part,\r\n    leftParts: leftParts,\r\n    rightParts: rightParts,\r\n    left: left,\r\n    right: right,\r\n    postparsed: postparsed\r\n  });\r\n\r\n  if (!inner.length) {\r\n    inner.expanded = [leftParts, rightParts];\r\n    inner = [inner];\r\n  }\r\n\r\n  return {\r\n    left: left,\r\n    right: right,\r\n    inner: inner\r\n  };\r\n}\r\n\r\nfunction expandToOne(postparsed, options) {\r\n  var errors = [];\r\n\r\n  if (postparsed.errors) {\r\n    errors = postparsed.errors;\r\n    postparsed = postparsed.postparsed;\r\n  }\r\n\r\n  var results = [];\r\n\r\n  for (var i = 0, len = postparsed.length; i < len; i++) {\r\n    var part = postparsed[i];\r\n\r\n    if (part.type === \"placeholder\" && part.module === options.moduleName) {\r\n      try {\r\n        var result = expandOne(part, i, postparsed, options);\r\n        i = result.right;\r\n        results.push(result);\r\n      } catch (error) {\r\n        if (error instanceof XTTemplateError) {\r\n          errors.push(error);\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  var newParsed = [];\r\n  var currentResult = 0;\r\n\r\n  for (var _i = 0, _len = postparsed.length; _i < _len; _i++) {\r\n    var _part = postparsed[_i];\r\n    var _result = results[currentResult];\r\n\r\n    if (_result && _result.left === _i) {\r\n      newParsed.push.apply(newParsed, _toConsumableArray(results[currentResult].inner));\r\n      currentResult++;\r\n      _i = _result.right;\r\n    } else {\r\n      newParsed.push(_part);\r\n    }\r\n  }\r\n\r\n  return {\r\n    postparsed: newParsed,\r\n    errors: errors\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  expandToOne: expandToOne,\r\n  getExpandToDefault: getExpandToDefault\r\n};","\r\n\r\nfunction emptyFun() {}\r\n\r\nfunction identity(i) {\r\n  return i;\r\n}\r\n\r\nmodule.exports = function (module) {\r\n  var defaults = {\r\n    set: emptyFun,\r\n    parse: emptyFun,\r\n    render: emptyFun,\r\n    getTraits: emptyFun,\r\n    getFileType: emptyFun,\r\n    nullGetter: emptyFun,\r\n    optionsTransformer: identity,\r\n    postrender: identity,\r\n    errorsTransformer: identity,\r\n    getRenderedMap: identity,\r\n    preparse: identity,\r\n    postparse: identity,\r\n    on: emptyFun,\r\n    resolve: emptyFun\r\n  };\r\n\r\n  if (Object.keys(defaults).every(function (key) {\r\n    return !module[key];\r\n  })) {\r\n    throw new Error(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\r\n  }\r\n\r\n  Object.keys(defaults).forEach(function (key) {\r\n    module[key] = module[key] || defaults[key];\r\n  });\r\n  return module;\r\n};","\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar _require = require(\"./errors\"),\r\n    getScopeParserExecutionError = _require.getScopeParserExecutionError;\r\n\r\nvar _require2 = require(\"./utils\"),\r\n    last = _require2.last;\r\n\r\nvar _require3 = require(\"./doc-utils\"),\r\n    concatArrays = _require3.concatArrays;\r\n\r\nfunction find(list, fn) {\r\n  var length = list.length >>> 0;\r\n  var value;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    value = list[i];\r\n\r\n    if (fn.call(this, value, i, list)) {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction _getValue(tag, meta, num) {\r\n  var _this = this;\r\n\r\n  var scope = this.scopeList[num];\r\n\r\n  if (this.root.finishedResolving) {\r\n    var w = this.resolved;\r\n    this.scopePath.forEach(function (p, index) {\r\n      var lIndex = _this.scopeLindex[index];\r\n      w = find(w, function (r) {\r\n        return r.lIndex === lIndex;\r\n      });\r\n      w = w.value[_this.scopePathItem[index]];\r\n    });\r\n    return [this.scopePath.length - 1, find(w, function (r) {\r\n      return meta.part.lIndex === r.lIndex;\r\n    }).value];\r\n  } // search in the scopes (in reverse order) and keep the first defined value\r\n\r\n\r\n  var result;\r\n  var parser;\r\n\r\n  if (!this.cachedParsers || !meta.part) {\r\n    parser = this.parser(tag, {\r\n      scopePath: this.scopePath\r\n    });\r\n  } else if (this.cachedParsers[meta.part.lIndex]) {\r\n    parser = this.cachedParsers[meta.part.lIndex];\r\n  } else {\r\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\r\n      scopePath: this.scopePath\r\n    });\r\n  }\r\n\r\n  try {\r\n    result = parser.get(scope, this.getContext(meta, num));\r\n  } catch (error) {\r\n    throw getScopeParserExecutionError({\r\n      tag: tag,\r\n      scope: scope,\r\n      error: error,\r\n      offset: meta.part.offset\r\n    });\r\n  }\r\n\r\n  if (result == null && num > 0) {\r\n    return _getValue.call(this, tag, meta, num - 1);\r\n  }\r\n\r\n  return [num, result];\r\n}\r\n\r\nfunction _getValueAsync(tag, meta, num) {\r\n  var _this2 = this;\r\n\r\n  var scope = this.scopeList[num]; // search in the scopes (in reverse order) and keep the first defined value\r\n\r\n  var parser;\r\n\r\n  if (!this.cachedParsers || !meta.part) {\r\n    parser = this.parser(tag, {\r\n      scopePath: this.scopePath\r\n    });\r\n  } else if (this.cachedParsers[meta.part.lIndex]) {\r\n    parser = this.cachedParsers[meta.part.lIndex];\r\n  } else {\r\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\r\n      scopePath: this.scopePath\r\n    });\r\n  }\r\n\r\n  return Promise.resolve().then(function () {\r\n    return parser.get(scope, _this2.getContext(meta, num));\r\n  })[\"catch\"](function (error) {\r\n    throw getScopeParserExecutionError({\r\n      tag: tag,\r\n      scope: scope,\r\n      error: error,\r\n      offset: meta.part.offset\r\n    });\r\n  }).then(function (result) {\r\n    if (result == null && num > 0) {\r\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\r\n    }\r\n\r\n    return result;\r\n  });\r\n} // This class responsibility is to manage the scope\r\n\r\n\r\nvar ScopeManager = /*#__PURE__*/function () {\r\n  function ScopeManager(options) {\r\n    _classCallCheck(this, ScopeManager);\r\n\r\n    this.root = options.root || this;\r\n    this.scopePath = options.scopePath;\r\n    this.scopePathItem = options.scopePathItem;\r\n    this.scopePathLength = options.scopePathLength;\r\n    this.scopeList = options.scopeList;\r\n    this.scopeLindex = options.scopeLindex;\r\n    this.parser = options.parser;\r\n    this.resolved = options.resolved;\r\n    this.cachedParsers = options.cachedParsers;\r\n  }\r\n\r\n  _createClass(ScopeManager, [{\r\n    key: \"loopOver\",\r\n    value: function loopOver(tag, functor, inverted, meta) {\r\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\r\n    }\r\n  }, {\r\n    key: \"functorIfInverted\",\r\n    value: function functorIfInverted(inverted, functor, value, i, length) {\r\n      if (inverted) {\r\n        functor(value, i, length);\r\n      }\r\n\r\n      return inverted;\r\n    }\r\n  }, {\r\n    key: \"isValueFalsy\",\r\n    value: function isValueFalsy(value, type) {\r\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\r\n    }\r\n  }, {\r\n    key: \"loopOverValue\",\r\n    value: function loopOverValue(value, functor, inverted) {\r\n      if (this.root.finishedResolving) {\r\n        inverted = false;\r\n      }\r\n\r\n      var type = Object.prototype.toString.call(value);\r\n\r\n      if (this.isValueFalsy(value, type)) {\r\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\r\n      }\r\n\r\n      if (type === \"[object Array]\") {\r\n        for (var i = 0; i < value.length; i++) {\r\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      if (type === \"[object Object]\") {\r\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\r\n      }\r\n\r\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\r\n    }\r\n  }, {\r\n    key: \"getValue\",\r\n    value: function getValue(tag, meta) {\r\n      var _getValue$call = _getValue.call(this, tag, meta, this.scopeList.length - 1),\r\n          _getValue$call2 = _slicedToArray(_getValue$call, 2),\r\n          num = _getValue$call2[0],\r\n          result = _getValue$call2[1];\r\n\r\n      this.num = num;\r\n      return result;\r\n    }\r\n  }, {\r\n    key: \"getValueAsync\",\r\n    value: function getValueAsync(tag, meta) {\r\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1);\r\n    }\r\n  }, {\r\n    key: \"getContext\",\r\n    value: function getContext(meta, num) {\r\n      return {\r\n        num: num,\r\n        meta: meta,\r\n        scopeList: this.scopeList,\r\n        resolved: this.resolved,\r\n        scopePath: this.scopePath,\r\n        scopePathItem: this.scopePathItem,\r\n        scopePathLength: this.scopePathLength\r\n      };\r\n    }\r\n  }, {\r\n    key: \"createSubScopeManager\",\r\n    value: function createSubScopeManager(scope, tag, i, part, length) {\r\n      return new ScopeManager({\r\n        root: this.root,\r\n        resolved: this.resolved,\r\n        parser: this.parser,\r\n        cachedParsers: this.cachedParsers,\r\n        scopeList: concatArrays([this.scopeList, [scope]]),\r\n        scopePath: concatArrays([this.scopePath, [tag]]),\r\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\r\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\r\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return ScopeManager;\r\n}();\r\n\r\nmodule.exports = function (options) {\r\n  options.scopePath = [];\r\n  options.scopePathItem = [];\r\n  options.scopePathLength = [];\r\n  options.scopeLindex = [];\r\n  options.scopeList = [options.tags];\r\n  return new ScopeManager(options);\r\n};","\r\n\r\nvar ctXML = \"[Content_Types].xml\";\r\n\r\nfunction collectContentTypes(overrides, defaults, zip) {\r\n  var partNames = {};\r\n\r\n  for (var i = 0, len = overrides.length; i < len; i++) {\r\n    var override = overrides[i];\r\n    var contentType = override.getAttribute(\"ContentType\");\r\n    var partName = override.getAttribute(\"PartName\").substr(1);\r\n    partNames[partName] = contentType;\r\n  }\r\n\r\n  var _loop = function _loop(_i, _len) {\r\n    var def = defaults[_i];\r\n    var contentType = def.getAttribute(\"ContentType\");\r\n    var extension = def.getAttribute(\"Extension\"); // eslint-disable-next-line no-loop-func\r\n\r\n    zip.file(/./).map(function (_ref) {\r\n      var name = _ref.name;\r\n\r\n      if (name.slice(name.length - extension.length - 1) === \".xml\" && !partNames[name] && name !== ctXML) {\r\n        partNames[name] = contentType;\r\n      }\r\n    });\r\n  };\r\n\r\n  for (var _i = 0, _len = defaults.length; _i < _len; _i++) {\r\n    _loop(_i, _len);\r\n  }\r\n\r\n  return partNames;\r\n}\r\n\r\nmodule.exports = collectContentTypes;","\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar wrapper = require(\"../module-wrapper\");\r\n\r\nvar _require = require(\"../doc-utils\"),\r\n    concatArrays = _require.concatArrays;\r\n\r\nvar filetypes = require(\"../filetypes\");\r\n\r\nvar Common = /*#__PURE__*/function () {\r\n  function Common() {\r\n    _classCallCheck(this, Common);\r\n\r\n    this.name = \"Common\";\r\n  }\r\n\r\n  _createClass(Common, [{\r\n    key: \"set\",\r\n    value: function set(_ref) {\r\n      var invertedContentTypes = _ref.invertedContentTypes;\r\n\r\n      if (invertedContentTypes) {\r\n        this.invertedContentTypes = invertedContentTypes;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"getFileType\",\r\n    value: function getFileType(_ref2) {\r\n      var doc = _ref2.doc;\r\n      var invertedContentTypes = this.invertedContentTypes;\r\n\r\n      if (!this.invertedContentTypes) {\r\n        return;\r\n      }\r\n\r\n      var keys = Object.keys(filetypes);\r\n\r\n      for (var i = 0, len = keys.length; i < len; i++) {\r\n        var ftCandidate = keys[i];\r\n        var contentTypes = filetypes[ftCandidate];\r\n\r\n        for (var j = 0, len2 = contentTypes.length; j < len2; j++) {\r\n          var ct = contentTypes[j];\r\n\r\n          if (invertedContentTypes[ct]) {\r\n            doc.targets = concatArrays([doc.targets, invertedContentTypes[ct]]);\r\n            return ftCandidate;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }]);\r\n\r\n  return Common;\r\n}();\r\n\r\nmodule.exports = function () {\r\n  return wrapper(new Common());\r\n};","\r\n\r\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\r\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\r\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\r\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\r\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\r\nvar filetypes = {\r\n  docx: [docxContentType, docxmContentType, dotxContentType, dotmContentType],\r\n  pptx: [pptxContentType]\r\n};\r\nmodule.exports = filetypes;","\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nvar _require = require(\"./errors\"),\r\n    getUnclosedTagException = _require.getUnclosedTagException,\r\n    getUnopenedTagException = _require.getUnopenedTagException,\r\n    getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\r\n    getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\r\n    throwMalformedXml = _require.throwMalformedXml,\r\n    throwXmlInvalid = _require.throwXmlInvalid;\r\n\r\nvar _require2 = require(\"./doc-utils\"),\r\n    concatArrays = _require2.concatArrays,\r\n    isTextStart = _require2.isTextStart,\r\n    isTextEnd = _require2.isTextEnd;\r\n\r\nvar NONE = -2;\r\nvar EQUAL = 0;\r\nvar START = -1;\r\nvar END = 1;\r\n\r\nfunction inRange(range, match) {\r\n  return range[0] <= match.offset && match.offset < range[1];\r\n}\r\n\r\nfunction updateInTextTag(part, inTextTag) {\r\n  if (isTextStart(part)) {\r\n    if (inTextTag) {\r\n      throwMalformedXml(part);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  if (isTextEnd(part)) {\r\n    if (!inTextTag) {\r\n      throwMalformedXml(part);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  return inTextTag;\r\n}\r\n\r\nfunction getTag(tag) {\r\n  var position = \"\";\r\n  var start = 1;\r\n  var end = tag.indexOf(\" \");\r\n\r\n  if (tag[tag.length - 2] === \"/\") {\r\n    position = \"selfclosing\";\r\n\r\n    if (end === -1) {\r\n      end = tag.length - 2;\r\n    }\r\n  } else if (tag[1] === \"/\") {\r\n    start = 2;\r\n    position = \"end\";\r\n\r\n    if (end === -1) {\r\n      end = tag.length - 1;\r\n    }\r\n  } else {\r\n    position = \"start\";\r\n\r\n    if (end === -1) {\r\n      end = tag.length - 1;\r\n    }\r\n  }\r\n\r\n  return {\r\n    tag: tag.slice(start, end),\r\n    position: position\r\n  };\r\n}\r\n\r\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\r\n  var cursor = 0;\r\n  var contentLength = content.length;\r\n  var allMatches = concatArrays([textMatchArray.map(function (tag) {\r\n    return {\r\n      tag: tag,\r\n      text: true\r\n    };\r\n  }), othersMatchArray.map(function (tag) {\r\n    return {\r\n      tag: tag,\r\n      text: false\r\n    };\r\n  })]).reduce(function (allMatches, t) {\r\n    allMatches[t.tag] = t.text;\r\n    return allMatches;\r\n  }, {});\r\n  var totalMatches = [];\r\n\r\n  while (cursor < contentLength) {\r\n    cursor = content.indexOf(\"<\", cursor);\r\n\r\n    if (cursor === -1) {\r\n      break;\r\n    }\r\n\r\n    var offset = cursor;\r\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\r\n    cursor = content.indexOf(\">\", cursor);\r\n\r\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\r\n      throwXmlInvalid(content, offset);\r\n    }\r\n\r\n    var tagText = content.slice(offset, cursor + 1);\r\n\r\n    var _getTag = getTag(tagText),\r\n        tag = _getTag.tag,\r\n        position = _getTag.position;\r\n\r\n    var text = allMatches[tag];\r\n\r\n    if (text == null) {\r\n      continue;\r\n    }\r\n\r\n    totalMatches.push({\r\n      type: \"tag\",\r\n      position: position,\r\n      text: text,\r\n      offset: offset,\r\n      value: tagText,\r\n      tag: tag\r\n    });\r\n  }\r\n\r\n  return totalMatches;\r\n}\r\n\r\nfunction getDelimiterErrors(delimiterMatches, fullText, ranges) {\r\n  if (delimiterMatches.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  var errors = [];\r\n  var inDelimiter = false;\r\n  var lastDelimiterMatch = {\r\n    offset: 0\r\n  };\r\n  var xtag;\r\n  var rangeIndex = 0;\r\n  delimiterMatches.forEach(function (delimiterMatch) {\r\n    while (ranges[rangeIndex + 1]) {\r\n      if (ranges[rangeIndex + 1].offset > delimiterMatch.offset) {\r\n        break;\r\n      }\r\n\r\n      rangeIndex++;\r\n    }\r\n\r\n    xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\r\n\r\n    if (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\r\n      if (delimiterMatch.position === \"start\") {\r\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\r\n          xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset + lastDelimiterMatch.length + 4);\r\n          errors.push(getDuplicateOpenTagException({\r\n            xtag: xtag,\r\n            offset: lastDelimiterMatch.offset\r\n          }));\r\n        } else {\r\n          errors.push(getUnclosedTagException({\r\n            xtag: xtag,\r\n            offset: lastDelimiterMatch.offset\r\n          }));\r\n        }\r\n\r\n        delimiterMatch.error = true;\r\n      } else {\r\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\r\n          xtag = fullText.substr(lastDelimiterMatch.offset - 4, delimiterMatch.offset - lastDelimiterMatch.offset + 4 + lastDelimiterMatch.length);\r\n          errors.push(getDuplicateCloseTagException({\r\n            xtag: xtag,\r\n            offset: lastDelimiterMatch.offset\r\n          }));\r\n        } else {\r\n          errors.push(getUnopenedTagException({\r\n            xtag: xtag,\r\n            offset: delimiterMatch.offset\r\n          }));\r\n        }\r\n\r\n        delimiterMatch.error = true;\r\n      }\r\n    } else {\r\n      inDelimiter = !inDelimiter;\r\n    }\r\n\r\n    lastDelimiterMatch = delimiterMatch;\r\n  });\r\n  var delimiterMatch = {\r\n    offset: fullText.length\r\n  };\r\n  xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\r\n\r\n  if (inDelimiter) {\r\n    errors.push(getUnclosedTagException({\r\n      xtag: xtag,\r\n      offset: lastDelimiterMatch.offset\r\n    }));\r\n    delimiterMatch.error = true;\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nfunction compareOffsets(startOffset, endOffset) {\r\n  if (startOffset === -1 && endOffset === -1) {\r\n    return NONE;\r\n  }\r\n\r\n  if (startOffset === endOffset) {\r\n    return EQUAL;\r\n  }\r\n\r\n  if (startOffset === -1 || endOffset === -1) {\r\n    return endOffset < startOffset ? START : END;\r\n  }\r\n\r\n  return startOffset < endOffset ? START : END;\r\n}\r\n\r\nfunction splitDelimiters(inside) {\r\n  var newDelimiters = inside.split(\" \");\r\n\r\n  if (newDelimiters.length !== 2) {\r\n    throw new Error(\"New Delimiters cannot be parsed\");\r\n  }\r\n\r\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\r\n      start = _newDelimiters[0],\r\n      end = _newDelimiters[1];\r\n\r\n  if (start.length === 0 || end.length === 0) {\r\n    throw new Error(\"New Delimiters cannot be parsed\");\r\n  }\r\n\r\n  return [start, end];\r\n}\r\n\r\nfunction getAllIndexes(fullText, delimiters) {\r\n  var indexes = [];\r\n  var start = delimiters.start,\r\n      end = delimiters.end;\r\n  var offset = -1;\r\n  var insideTag = false;\r\n\r\n  while (true) {\r\n    var startOffset = fullText.indexOf(start, offset + 1);\r\n    var endOffset = fullText.indexOf(end, offset + 1);\r\n    var position = null;\r\n    var len = void 0;\r\n    var compareResult = compareOffsets(startOffset, endOffset);\r\n\r\n    if (compareResult === NONE) {\r\n      return indexes;\r\n    }\r\n\r\n    if (compareResult === EQUAL) {\r\n      if (!insideTag) {\r\n        compareResult = START;\r\n      } else {\r\n        compareResult = END;\r\n      }\r\n    }\r\n\r\n    if (compareResult === END) {\r\n      insideTag = false;\r\n      offset = endOffset;\r\n      position = \"end\";\r\n      len = end.length;\r\n    }\r\n\r\n    if (compareResult === START) {\r\n      insideTag = true;\r\n      offset = startOffset;\r\n      position = \"start\";\r\n      len = start.length;\r\n    }\r\n\r\n    if (position === \"start\" && fullText[offset + start.length] === \"=\") {\r\n      indexes.push({\r\n        offset: startOffset,\r\n        position: \"start\",\r\n        length: start.length,\r\n        changedelimiter: true\r\n      });\r\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\r\n\r\n      var _endOffset = fullText.indexOf(end, nextEqual + 1);\r\n\r\n      indexes.push({\r\n        offset: _endOffset,\r\n        position: \"end\",\r\n        length: end.length,\r\n        changedelimiter: true\r\n      });\r\n\r\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\r\n\r\n      var _splitDelimiters = splitDelimiters(_insideTag);\r\n\r\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\r\n\r\n      start = _splitDelimiters2[0];\r\n      end = _splitDelimiters2[1];\r\n      offset = _endOffset;\r\n      continue;\r\n    }\r\n\r\n    indexes.push({\r\n      offset: offset,\r\n      position: position,\r\n      length: len\r\n    });\r\n  }\r\n}\r\n\r\nfunction parseDelimiters(innerContentParts, delimiters) {\r\n  var full = innerContentParts.map(function (p) {\r\n    return p.value;\r\n  }).join(\"\");\r\n  var delimiterMatches = getAllIndexes(full, delimiters);\r\n  var offset = 0;\r\n  var ranges = innerContentParts.map(function (part) {\r\n    offset += part.value.length;\r\n    return {\r\n      offset: offset - part.value.length,\r\n      lIndex: part.lIndex\r\n    };\r\n  });\r\n  var errors = getDelimiterErrors(delimiterMatches, full, ranges);\r\n  var cutNext = 0;\r\n  var delimiterIndex = 0;\r\n  var parsed = ranges.map(function (p, i) {\r\n    var offset = p.offset;\r\n    var range = [offset, offset + innerContentParts[i].value.length];\r\n    var partContent = innerContentParts[i].value;\r\n    var delimitersInOffset = [];\r\n\r\n    while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\r\n      delimitersInOffset.push(delimiterMatches[delimiterIndex]);\r\n      delimiterIndex++;\r\n    }\r\n\r\n    var parts = [];\r\n    var cursor = 0;\r\n\r\n    if (cutNext > 0) {\r\n      cursor = cutNext;\r\n      cutNext = 0;\r\n    }\r\n\r\n    var insideDelimiterChange;\r\n    delimitersInOffset.forEach(function (delimiterInOffset) {\r\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\r\n\r\n      if (value.length > 0) {\r\n        if (insideDelimiterChange) {\r\n          if (delimiterInOffset.changedelimiter) {\r\n            cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\r\n            insideDelimiterChange = delimiterInOffset.position === \"start\";\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        parts.push({\r\n          type: \"content\",\r\n          value: value,\r\n          offset: cursor + offset\r\n        });\r\n        cursor += value.length;\r\n      }\r\n\r\n      var delimiterPart = {\r\n        type: \"delimiter\",\r\n        position: delimiterInOffset.position,\r\n        offset: cursor + offset\r\n      };\r\n\r\n      if (delimiterInOffset.error) {\r\n        delimiterPart.error = delimiterInOffset.error;\r\n      }\r\n\r\n      if (delimiterInOffset.changedelimiter) {\r\n        insideDelimiterChange = delimiterInOffset.position === \"start\";\r\n        cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\r\n        return;\r\n      }\r\n\r\n      parts.push(delimiterPart);\r\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\r\n    });\r\n    cutNext = cursor - partContent.length;\r\n    var value = partContent.substr(cursor);\r\n\r\n    if (value.length > 0) {\r\n      parts.push({\r\n        type: \"content\",\r\n        value: value,\r\n        offset: offset\r\n      });\r\n    }\r\n\r\n    return parts;\r\n  }, this);\r\n  return {\r\n    parsed: parsed,\r\n    errors: errors\r\n  };\r\n}\r\n\r\nfunction getContentParts(xmlparsed) {\r\n  var inTextTag = false;\r\n  var innerContentParts = [];\r\n  xmlparsed.forEach(function (part) {\r\n    inTextTag = updateInTextTag(part, inTextTag);\r\n\r\n    if (inTextTag && part.type === \"content\") {\r\n      innerContentParts.push(part);\r\n    }\r\n  });\r\n  return innerContentParts;\r\n}\r\n\r\nmodule.exports = {\r\n  parseDelimiters: parseDelimiters,\r\n  parse: function parse(xmlparsed, delimiters) {\r\n    var inTextTag = false;\r\n\r\n    var _parseDelimiters = parseDelimiters(getContentParts(xmlparsed), delimiters),\r\n        delimiterParsed = _parseDelimiters.parsed,\r\n        errors = _parseDelimiters.errors;\r\n\r\n    var lexed = [];\r\n    var index = 0;\r\n    xmlparsed.forEach(function (part) {\r\n      inTextTag = updateInTextTag(part, inTextTag);\r\n\r\n      if (part.type === \"content\") {\r\n        part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\r\n      }\r\n\r\n      if (inTextTag && part.type === \"content\") {\r\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\r\n          if (p.type === \"content\") {\r\n            p.position = \"insidetag\";\r\n          }\r\n\r\n          return p;\r\n        }));\r\n        index++;\r\n      } else {\r\n        lexed.push(part);\r\n      }\r\n    });\r\n    lexed = lexed.map(function (p, i) {\r\n      p.lIndex = i;\r\n      return p;\r\n    });\r\n    return {\r\n      errors: errors,\r\n      lexed: lexed\r\n    };\r\n  },\r\n  xmlparse: function xmlparse(content, xmltags) {\r\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\r\n    var cursor = 0;\r\n    var parsed = matches.reduce(function (parsed, match) {\r\n      var value = content.substr(cursor, match.offset - cursor);\r\n\r\n      if (value.length > 0) {\r\n        parsed.push({\r\n          type: \"content\",\r\n          value: value\r\n        });\r\n      }\r\n\r\n      cursor = match.offset + match.value.length;\r\n      delete match.offset;\r\n\r\n      if (match.value.length > 0) {\r\n        parsed.push(match);\r\n      }\r\n\r\n      return parsed;\r\n    }, []);\r\n    var value = content.substr(cursor);\r\n\r\n    if (value.length > 0) {\r\n      parsed.push({\r\n        type: \"content\",\r\n        value: value\r\n      });\r\n    }\r\n\r\n    return parsed;\r\n  }\r\n};","\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar _require = require(\"./doc-utils\"),\r\n    wordToUtf8 = _require.wordToUtf8,\r\n    convertSpaces = _require.convertSpaces,\r\n    defaults = _require.defaults;\r\n\r\nvar xmlMatcher = require(\"./xml-matcher\");\r\n\r\nvar _require2 = require(\"./errors\"),\r\n    throwContentMustBeString = _require2.throwContentMustBeString;\r\n\r\nvar Lexer = require(\"./lexer\");\r\n\r\nvar Parser = require(\"./parser.js\");\r\n\r\nvar _render = require(\"./render.js\");\r\n\r\nvar postrender = require(\"./postrender.js\");\r\n\r\nvar resolve = require(\"./resolve.js\");\r\n\r\nvar joinUncorrupt = require(\"./join-uncorrupt\");\r\n\r\nfunction _getFullText(content, tagsXmlArray) {\r\n  var matcher = xmlMatcher(content, tagsXmlArray);\r\n  var result = matcher.matches.map(function (match) {\r\n    return match.array[2];\r\n  });\r\n  return wordToUtf8(convertSpaces(result.join(\"\")));\r\n}\r\n\r\nmodule.exports = /*#__PURE__*/function () {\r\n  function XmlTemplater(content, options) {\r\n    _classCallCheck(this, XmlTemplater);\r\n\r\n    this.filePath = options.filePath;\r\n    this.cachedParsers = {};\r\n    this.modules = options.modules;\r\n    this.fileTypeConfig = options.fileTypeConfig;\r\n    this.contentType = options.contentType;\r\n    Object.keys(defaults).map(function (key) {\r\n      this[key] = options[key] != null ? options[key] : defaults[key];\r\n    }, this);\r\n    this.setModules({\r\n      inspect: {\r\n        filePath: this.filePath\r\n      }\r\n    });\r\n    this.load(content);\r\n  }\r\n\r\n  _createClass(XmlTemplater, [{\r\n    key: \"load\",\r\n    value: function load(content) {\r\n      if (typeof content !== \"string\") {\r\n        throwContentMustBeString(_typeof(content));\r\n      }\r\n\r\n      this.content = content;\r\n    }\r\n  }, {\r\n    key: \"setTags\",\r\n    value: function setTags(tags) {\r\n      this.tags = tags != null ? tags : {};\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"resolveTags\",\r\n    value: function resolveTags(tags) {\r\n      var _this = this;\r\n\r\n      this.tags = tags != null ? tags : {};\r\n      var options = this.getOptions();\r\n      options.scopeManager = this.scopeManager;\r\n      options.resolve = resolve;\r\n      return resolve(options).then(function (_ref) {\r\n        var resolved = _ref.resolved,\r\n            errors = _ref.errors;\r\n        errors.forEach(function (error) {\r\n          // error properties might not be defined if some foreign\r\n          // (unhandled error not throw by docxtemplater willingly) is\r\n          // thrown.\r\n          error.properties = error.properties || {};\r\n          error.properties.file = _this.filePath;\r\n        });\r\n\r\n        if (errors.length !== 0) {\r\n          throw errors;\r\n        }\r\n\r\n        return Promise.all(resolved).then(function (resolved) {\r\n          options.scopeManager.finishedResolving = true;\r\n          options.scopeManager.resolved = resolved;\r\n\r\n          _this.setModules({\r\n            inspect: {\r\n              resolved: resolved\r\n            }\r\n          });\r\n\r\n          return resolved;\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: \"getFullText\",\r\n    value: function getFullText() {\r\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\r\n    }\r\n  }, {\r\n    key: \"setModules\",\r\n    value: function setModules(obj) {\r\n      this.modules.forEach(function (module) {\r\n        module.set(obj);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"preparse\",\r\n    value: function preparse() {\r\n      this.allErrors = [];\r\n      this.xmllexed = Lexer.xmlparse(this.content, {\r\n        text: this.fileTypeConfig.tagsXmlTextArray,\r\n        other: this.fileTypeConfig.tagsXmlLexedArray\r\n      });\r\n      this.setModules({\r\n        inspect: {\r\n          xmllexed: this.xmllexed\r\n        }\r\n      });\r\n\r\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters),\r\n          lexed = _Lexer$parse.lexed,\r\n          lexerErrors = _Lexer$parse.errors;\r\n\r\n      this.allErrors = this.allErrors.concat(lexerErrors);\r\n      this.lexed = lexed;\r\n      this.setModules({\r\n        inspect: {\r\n          lexed: this.lexed\r\n        }\r\n      });\r\n      var options = this.getOptions();\r\n      Parser.preparse(this.lexed, this.modules, options);\r\n    }\r\n  }, {\r\n    key: \"parse\",\r\n    value: function parse() {\r\n      this.setModules({\r\n        inspect: {\r\n          filePath: this.filePath\r\n        }\r\n      });\r\n      var options = this.getOptions();\r\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\r\n      this.setModules({\r\n        inspect: {\r\n          parsed: this.parsed\r\n        }\r\n      });\r\n\r\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\r\n          postparsed = _Parser$postparse.postparsed,\r\n          postparsedErrors = _Parser$postparse.errors;\r\n\r\n      this.postparsed = postparsed;\r\n      this.setModules({\r\n        inspect: {\r\n          postparsed: this.postparsed\r\n        }\r\n      });\r\n      this.allErrors = this.allErrors.concat(postparsedErrors);\r\n      this.errorChecker(this.allErrors);\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"errorChecker\",\r\n    value: function errorChecker(errors) {\r\n      var _this2 = this;\r\n\r\n      if (errors.length) {\r\n        errors.forEach(function (error) {\r\n          // error properties might not be defined if some foreign\r\n          // (unhandled error not thrown by docxtemplater willingly) is\r\n          // thrown.\r\n          error.properties = error.properties || {};\r\n          error.properties.file = _this2.filePath;\r\n        });\r\n        this.modules.forEach(function (module) {\r\n          errors = module.errorsTransformer(errors);\r\n        });\r\n      }\r\n    }\r\n  }, {\r\n    key: \"baseNullGetter\",\r\n    value: function baseNullGetter(part, sm) {\r\n      var _this3 = this;\r\n\r\n      var value = this.modules.reduce(function (value, module) {\r\n        if (value != null) {\r\n          return value;\r\n        }\r\n\r\n        return module.nullGetter(part, sm, _this3);\r\n      }, null);\r\n\r\n      if (value != null) {\r\n        return value;\r\n      }\r\n\r\n      return this.nullGetter(part, sm);\r\n    }\r\n  }, {\r\n    key: \"getOptions\",\r\n    value: function getOptions() {\r\n      return {\r\n        compiled: this.postparsed,\r\n        cachedParsers: this.cachedParsers,\r\n        tags: this.tags,\r\n        modules: this.modules,\r\n        parser: this.parser,\r\n        contentType: this.contentType,\r\n        baseNullGetter: this.baseNullGetter.bind(this),\r\n        filePath: this.filePath,\r\n        fileTypeConfig: this.fileTypeConfig,\r\n        linebreaks: this.linebreaks\r\n      };\r\n    }\r\n  }, {\r\n    key: \"render\",\r\n    value: function render(to) {\r\n      this.filePath = to;\r\n      var options = this.getOptions();\r\n      options.resolved = this.scopeManager.resolved;\r\n      options.scopeManager = this.scopeManager;\r\n      options.render = _render;\r\n      options.joinUncorrupt = joinUncorrupt;\r\n\r\n      var _render2 = _render(options),\r\n          errors = _render2.errors,\r\n          parts = _render2.parts;\r\n\r\n      this.allErrors = errors;\r\n      this.errorChecker(errors);\r\n\r\n      if (errors.length > 0) {\r\n        return this;\r\n      }\r\n\r\n      this.content = postrender(parts, options);\r\n      this.setModules({\r\n        inspect: {\r\n          content: this.content\r\n        }\r\n      });\r\n      return this;\r\n    }\r\n  }]);\r\n\r\n  return XmlTemplater;\r\n}();"," // res class responsibility is to parse the XML.\r\n\r\nvar _require = require(\"./doc-utils\"),\r\n    pregMatchAll = _require.pregMatchAll;\r\n\r\nfunction handleRecursiveCase(res) {\r\n  /*\r\n   * Because xmlTemplater is recursive (meaning it can call it self), we need to handle special cases where the XML is not valid:\r\n   * For example with res string \"I am</w:t></w:r></w:p><w:p><w:r><w:t>sleeping\",\r\n   *   - we need to match also the string that is inside an implicit <w:t> (that's the role of replacerUnshift) (in res case 'I am')\r\n   *   - we need to match the string that is at the right of a <w:t> (that's the role of replacerPush) (in res case 'sleeping')\r\n   * the test: describe \"scope calculation\" it \"should compute the scope between 2 <w:t>\" makes sure that res part of code works\r\n   * It should even work if they is no XML at all, for example if the code is just \"I am sleeping\", in res case however, they should only be one match\r\n   */\r\n  function replacerUnshift() {\r\n    var pn = {\r\n      array: Array.prototype.slice.call(arguments)\r\n    };\r\n    pn.array.shift();\r\n    var match = pn.array[0] + pn.array[1]; // add match so that pn[0] = whole match, pn[1]= first parenthesis,...\r\n\r\n    pn.array.unshift(match);\r\n    pn.array.pop();\r\n    var offset = pn.array.pop();\r\n    pn.offset = offset;\r\n    pn.first = true; // add at the beginning\r\n\r\n    res.matches.unshift(pn);\r\n  }\r\n\r\n  if (res.content.indexOf(\"<\") === -1 && res.content.indexOf(\">\") === -1) {\r\n    res.content.replace(/^()([^<>]*)$/, replacerUnshift);\r\n  }\r\n\r\n  var r = new RegExp(\"^()([^<]+)</(?:\".concat(res.tagsXmlArrayJoined, \")>\"));\r\n  res.content.replace(r, replacerUnshift);\r\n\r\n  function replacerPush() {\r\n    var pn = {\r\n      array: Array.prototype.slice.call(arguments)\r\n    };\r\n    pn.array.pop();\r\n    var offset = pn.array.pop();\r\n    pn.offset = offset;\r\n    pn.last = true;\r\n\r\n    if (pn.array[0].indexOf(\"/>\") !== -1) {\r\n      return;\r\n    } // add at the end\r\n\r\n\r\n    res.matches.push(pn);\r\n  }\r\n\r\n  r = new RegExp(\"(<(?:\".concat(res.tagsXmlArrayJoined, \")[^>]*>)([^>]+)$\"));\r\n  res.content.replace(r, replacerPush);\r\n  return res;\r\n}\r\n\r\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\r\n  var res = {};\r\n  res.content = content;\r\n  res.tagsXmlArray = tagsXmlArray;\r\n  res.tagsXmlArrayJoined = res.tagsXmlArray.join(\"|\");\r\n  var regexp = new RegExp(\"(?:(<(?:\".concat(res.tagsXmlArrayJoined, \")[^>]*>)([^<>]*)</(?:\").concat(res.tagsXmlArrayJoined, \")>)|(<(?:\").concat(res.tagsXmlArrayJoined, \")[^>]*/>)\"), \"g\");\r\n  res.matches = pregMatchAll(regexp, res.content);\r\n  return handleRecursiveCase(res);\r\n};","\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nvar _require = require(\"./doc-utils\"),\r\n    wordToUtf8 = _require.wordToUtf8,\r\n    concatArrays = _require.concatArrays;\r\n\r\nvar _require2 = require(\"./prefix-matcher\"),\r\n    match = _require2.match,\r\n    getValue = _require2.getValue,\r\n    getValues = _require2.getValues;\r\n\r\nfunction moduleParse(placeHolderContent, options) {\r\n  var modules = options.modules;\r\n  var startOffset = options.startOffset;\r\n  var endLindex = options.lIndex;\r\n  var moduleParsed;\r\n  options.offset = startOffset;\r\n  options.lIndex = endLindex;\r\n  options.match = match;\r\n  options.getValue = getValue;\r\n  options.getValues = getValues;\r\n\r\n  for (var i = 0, l = modules.length; i < l; i++) {\r\n    var _module = modules[i];\r\n    moduleParsed = _module.parse(placeHolderContent, options);\r\n\r\n    if (moduleParsed) {\r\n      moduleParsed.offset = startOffset;\r\n      moduleParsed.endLindex = endLindex;\r\n      moduleParsed.lIndex = endLindex;\r\n      moduleParsed.raw = placeHolderContent;\r\n      return moduleParsed;\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: \"placeholder\",\r\n    value: placeHolderContent,\r\n    offset: startOffset,\r\n    endLindex: endLindex,\r\n    lIndex: endLindex\r\n  };\r\n}\r\n\r\nvar parser = {\r\n  preparse: function preparse(parsed, modules, options) {\r\n    function preparse(parsed, options) {\r\n      return modules.forEach(function (module) {\r\n        module.preparse(parsed, options);\r\n      });\r\n    }\r\n\r\n    return {\r\n      preparsed: preparse(parsed, options)\r\n    };\r\n  },\r\n  postparse: function postparse(postparsed, modules, options) {\r\n    function getTraits(traitName, postparsed) {\r\n      return modules.map(function (module) {\r\n        return module.getTraits(traitName, postparsed);\r\n      });\r\n    }\r\n\r\n    var errors = [];\r\n\r\n    function _postparse(postparsed, options) {\r\n      return modules.reduce(function (postparsed, module) {\r\n        var r = module.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\r\n          postparse: function postparse(parsed, opts) {\r\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\r\n          },\r\n          getTraits: getTraits\r\n        }));\r\n\r\n        if (r == null) {\r\n          return postparsed;\r\n        }\r\n\r\n        if (r.errors) {\r\n          errors = concatArrays([errors, r.errors]);\r\n          return r.postparsed;\r\n        }\r\n\r\n        return r;\r\n      }, postparsed);\r\n    }\r\n\r\n    return {\r\n      postparsed: _postparse(postparsed, options),\r\n      errors: errors\r\n    };\r\n  },\r\n  parse: function parse(lexed, modules, options) {\r\n    var inPlaceHolder = false;\r\n    var placeHolderContent = \"\";\r\n    var startOffset;\r\n    var tailParts = [];\r\n    return lexed.reduce(function lexedToParsed(parsed, token) {\r\n      if (token.type === \"delimiter\") {\r\n        inPlaceHolder = token.position === \"start\";\r\n\r\n        if (token.position === \"end\") {\r\n          placeHolderContent = wordToUtf8(placeHolderContent);\r\n\r\n          options.parse = function (placeHolderContent) {\r\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\r\n              startOffset: startOffset,\r\n              modules: modules\r\n            }));\r\n          };\r\n\r\n          parsed.push(options.parse(placeHolderContent));\r\n          Array.prototype.push.apply(parsed, tailParts);\r\n          tailParts = [];\r\n        }\r\n\r\n        if (token.position === \"start\") {\r\n          tailParts = [];\r\n          startOffset = token.offset;\r\n        }\r\n\r\n        placeHolderContent = \"\";\r\n        return parsed;\r\n      }\r\n\r\n      if (!inPlaceHolder) {\r\n        parsed.push(token);\r\n        return parsed;\r\n      }\r\n\r\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\r\n        tailParts.push(token);\r\n        return parsed;\r\n      }\r\n\r\n      placeHolderContent += token.value;\r\n      return parsed;\r\n    }, []);\r\n  }\r\n};\r\nmodule.exports = parser;","\r\n\r\nfunction match(condition, placeHolderContent) {\r\n  if (typeof condition === \"string\") {\r\n    return placeHolderContent.substr(0, condition.length) === condition;\r\n  }\r\n\r\n  if (condition instanceof RegExp) {\r\n    return condition.test(placeHolderContent);\r\n  }\r\n}\r\n\r\nfunction getValue(condition, placeHolderContent) {\r\n  if (typeof condition === \"string\") {\r\n    return placeHolderContent.substr(condition.length);\r\n  }\r\n\r\n  if (condition instanceof RegExp) {\r\n    return placeHolderContent.match(condition)[1];\r\n  }\r\n}\r\n\r\nfunction getValues(condition, placeHolderContent) {\r\n  if (condition instanceof RegExp) {\r\n    return placeHolderContent.match(condition);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  match: match,\r\n  getValue: getValue,\r\n  getValues: getValues\r\n};","\r\n\r\nvar _require = require(\"./doc-utils\"),\r\n    concatArrays = _require.concatArrays;\r\n\r\nvar _require2 = require(\"./errors\"),\r\n    throwUnimplementedTagType = _require2.throwUnimplementedTagType;\r\n\r\nfunction moduleRender(part, options) {\r\n  var moduleRendered;\r\n\r\n  for (var i = 0, l = options.modules.length; i < l; i++) {\r\n    var _module = options.modules[i];\r\n    moduleRendered = _module.render(part, options);\r\n\r\n    if (moduleRendered) {\r\n      return moduleRendered;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction render(options) {\r\n  var baseNullGetter = options.baseNullGetter;\r\n  var compiled = options.compiled,\r\n      scopeManager = options.scopeManager;\r\n\r\n  options.nullGetter = function (part, sm) {\r\n    return baseNullGetter(part, sm || scopeManager);\r\n  };\r\n\r\n  if (!options.prefix) {\r\n    options.prefix = \"\";\r\n  }\r\n\r\n  if (options.index) {\r\n    options.prefix = options.prefix + options.index + \"-\";\r\n  }\r\n\r\n  var errors = [];\r\n  var parts = compiled.map(function (part, i) {\r\n    options.index = i;\r\n    var moduleRendered = moduleRender(part, options);\r\n\r\n    if (moduleRendered) {\r\n      if (moduleRendered.errors) {\r\n        errors = concatArrays([errors, moduleRendered.errors]);\r\n      }\r\n\r\n      return moduleRendered.value;\r\n    }\r\n\r\n    if (part.type === \"content\" || part.type === \"tag\") {\r\n      return part.value;\r\n    }\r\n\r\n    throwUnimplementedTagType(part, i);\r\n  });\r\n  return {\r\n    errors: errors,\r\n    parts: parts\r\n  };\r\n}\r\n\r\nmodule.exports = render;","\r\n\r\nfunction postrender(parts, options) {\r\n  for (var i = 0, l = options.modules.length; i < l; i++) {\r\n    var _module = options.modules[i];\r\n    parts = _module.postrender(parts, options);\r\n  }\r\n\r\n  return options.joinUncorrupt(parts, options);\r\n}\r\n\r\nmodule.exports = postrender;","\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction moduleResolve(part, options) {\r\n  var moduleResolved;\r\n\r\n  for (var i = 0, l = options.modules.length; i < l; i++) {\r\n    var _module = options.modules[i];\r\n    moduleResolved = _module.resolve(part, options);\r\n\r\n    if (moduleResolved) {\r\n      return moduleResolved;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction resolve(options) {\r\n  var resolved = [];\r\n  var baseNullGetter = options.baseNullGetter;\r\n  var compiled = options.compiled,\r\n      scopeManager = options.scopeManager;\r\n\r\n  options.nullGetter = function (part, sm) {\r\n    return baseNullGetter(part, sm || scopeManager);\r\n  };\r\n\r\n  options.resolved = resolved;\r\n  var errors = [];\r\n  return Promise.all(compiled.filter(function (part) {\r\n    return [\"content\", \"tag\"].indexOf(part.type) === -1;\r\n  }).reduce(function (promises, part) {\r\n    var moduleResolved = moduleResolve(part, options);\r\n    var result;\r\n\r\n    if (moduleResolved) {\r\n      result = moduleResolved.then(function (value) {\r\n        resolved.push({\r\n          tag: part.value,\r\n          value: value,\r\n          lIndex: part.lIndex\r\n        });\r\n      });\r\n    } else if (part.type === \"placeholder\") {\r\n      result = scopeManager.getValueAsync(part.value, {\r\n        part: part\r\n      }).then(function (value) {\r\n        if (value == null) {\r\n          value = options.nullGetter(part);\r\n        }\r\n\r\n        resolved.push({\r\n          tag: part.value,\r\n          value: value,\r\n          lIndex: part.lIndex\r\n        });\r\n        return value;\r\n      });\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    promises.push(result[\"catch\"](function (e) {\r\n      if (e.length > 1) {\r\n        errors.push.apply(errors, _toConsumableArray(e));\r\n      } else {\r\n        errors.push(e);\r\n      }\r\n    }));\r\n    return promises;\r\n  }, [])).then(function () {\r\n    return {\r\n      errors: errors,\r\n      resolved: resolved\r\n    };\r\n  });\r\n}\r\n\r\nmodule.exports = resolve;","\r\n\r\nvar _require = require(\"./doc-utils\"),\r\n    endsWith = _require.endsWith,\r\n    startsWith = _require.startsWith;\r\n\r\nvar filetypes = require(\"./filetypes\");\r\n\r\nfunction addEmptyParagraphAfterTable(parts) {\r\n  var beforeSectPr = false;\r\n\r\n  for (var i = parts.length - 1; i >= 0; i--) {\r\n    var part = parts[i];\r\n\r\n    if (startsWith(part, \"<w:sectPr\")) {\r\n      beforeSectPr = true;\r\n    }\r\n\r\n    if (beforeSectPr) {\r\n      var trimmed = part.trim();\r\n\r\n      if (endsWith(trimmed, \"</w:tbl>\")) {\r\n        parts.splice(i + 1, 0, \"<w:p><w:r><w:t></w:t></w:r></w:p>\");\r\n        return parts;\r\n      }\r\n\r\n      if (endsWith(trimmed, \"</w:p>\")) {\r\n        return parts;\r\n      }\r\n    }\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\nfunction joinUncorrupt(parts, options) {\r\n  var contains = options.fileTypeConfig.tagShouldContain || []; // Before doing this \"uncorruption\" method here, this was done with the `part.emptyValue` trick, however, there were some corruptions that were not handled, for example with a template like this :\r\n  //\r\n  // ------------------------------------------------\r\n  // | {-w:p falsy}My para{/falsy}   |              |\r\n  // | {-w:p falsy}My para{/falsy}   |              |\r\n  // ------------------------------------------------\r\n\r\n  var collecting = \"\";\r\n  var currentlyCollecting = -1;\r\n\r\n  if (!options.basePart && filetypes.docx.indexOf(options.contentType) !== -1) {\r\n    parts = addEmptyParagraphAfterTable(parts);\r\n  }\r\n\r\n  return parts.reduce(function (full, part) {\r\n    for (var i = 0, len = contains.length; i < len; i++) {\r\n      var _contains$i = contains[i],\r\n          tag = _contains$i.tag,\r\n          shouldContain = _contains$i.shouldContain,\r\n          value = _contains$i.value;\r\n      var startTagRegex = new RegExp(\"^(<(\".concat(tag, \")[^>]*>)$\"), \"g\");\r\n\r\n      if (currentlyCollecting === i) {\r\n        if (part === \"</\".concat(tag, \">\")) {\r\n          currentlyCollecting = -1;\r\n          return full + collecting + value + part;\r\n        }\r\n\r\n        collecting += part;\r\n\r\n        for (var j = 0, len2 = shouldContain.length; j < len2; j++) {\r\n          var sc = shouldContain[j];\r\n\r\n          if (part.indexOf(\"<\".concat(sc, \" \")) !== -1 || part.indexOf(\"<\".concat(sc, \">\")) !== -1) {\r\n            currentlyCollecting = -1;\r\n            return full + collecting;\r\n          }\r\n        }\r\n\r\n        return full;\r\n      }\r\n\r\n      if (currentlyCollecting === -1 && startTagRegex.test(part)) {\r\n        if (part[part.length - 2] === \"/\") {\r\n          return full;\r\n        }\r\n\r\n        currentlyCollecting = i;\r\n        collecting = part;\r\n        return full;\r\n      }\r\n    }\r\n\r\n    return full + part;\r\n  }, \"\");\r\n}\r\n\r\nmodule.exports = joinUncorrupt;","\r\n\r\nvar loopModule = require(\"./modules/loop\");\r\n\r\nvar spacePreserveModule = require(\"./modules/space-preserve\");\r\n\r\nvar rawXmlModule = require(\"./modules/rawxml\");\r\n\r\nvar expandPairTrait = require(\"./modules/expand-pair-trait\");\r\n\r\nvar render = require(\"./modules/render\");\r\n\r\nfunction PptXFileTypeConfig() {\r\n  return {\r\n    getTemplatedFiles: function getTemplatedFiles(zip) {\r\n      var slideTemplates = zip.file(/ppt\\/(slideMasters)\\/(slideMaster)\\d+\\.xml/).map(function (file) {\r\n        return file.name;\r\n      });\r\n      return slideTemplates.concat([\"ppt/presentation.xml\", \"docProps/app.xml\", \"docProps/core.xml\"]);\r\n    },\r\n    textPath: function textPath() {\r\n      return \"ppt/slides/slide1.xml\";\r\n    },\r\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\"],\r\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:table\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\"],\r\n    expandTags: [{\r\n      contains: \"a:tc\",\r\n      expand: \"a:tr\"\r\n    }],\r\n    onParagraphLoop: [{\r\n      contains: \"a:p\",\r\n      expand: \"a:p\",\r\n      onlyTextInTag: true\r\n    }],\r\n    tagRawXml: \"p:sp\",\r\n    tagTextXml: \"a:t\",\r\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\r\n    tagShouldContain: [{\r\n      tag: \"p:txBody\",\r\n      shouldContain: [\"a:p\"],\r\n      value: \"<a:p></a:p>\"\r\n    }, {\r\n      tag: \"a:txBody\",\r\n      shouldContain: [\"a:p\"],\r\n      value: \"<a:p></a:p>\"\r\n    }]\r\n  };\r\n}\r\n\r\nfunction DocXFileTypeConfig() {\r\n  return {\r\n    getTemplatedFiles: function getTemplatedFiles(zip) {\r\n      var baseTags = [\"docProps/core.xml\", \"docProps/app.xml\", \"word/settings.xml\"];\r\n      var headerFooters = zip.file(/word\\/(header|footer)\\d+\\.xml/).map(function (file) {\r\n        return file.name;\r\n      });\r\n      return headerFooters.concat(baseTags);\r\n    },\r\n    textPath: function textPath(doc) {\r\n      return doc.targets[0];\r\n    },\r\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"w:t\", \"m:t\", \"vt:lpstr\"],\r\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:table\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:sectPr\", \"w:headerReference\", \"w:footerReference\"],\r\n    expandTags: [{\r\n      contains: \"w:tc\",\r\n      expand: \"w:tr\"\r\n    }],\r\n    onParagraphLoop: [{\r\n      contains: \"w:p\",\r\n      expand: \"w:p\",\r\n      onlyTextInTag: true\r\n    }],\r\n    tagRawXml: \"w:p\",\r\n    tagTextXml: \"w:t\",\r\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\r\n    tagShouldContain: [{\r\n      tag: \"w:tc\",\r\n      shouldContain: [\"w:p\"],\r\n      value: \"<w:p></w:p>\"\r\n    }, {\r\n      tag: \"w:sdtContent\",\r\n      shouldContain: [\"w:p\", \"w:r\"],\r\n      value: \"<w:p></w:p>\"\r\n    }]\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  docx: DocXFileTypeConfig,\r\n  pptx: PptXFileTypeConfig\r\n};","\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar _require = require(\"../doc-utils\"),\r\n    mergeObjects = _require.mergeObjects,\r\n    chunkBy = _require.chunkBy,\r\n    last = _require.last,\r\n    isParagraphStart = _require.isParagraphStart,\r\n    isParagraphEnd = _require.isParagraphEnd,\r\n    isContent = _require.isContent,\r\n    startsWith = _require.startsWith;\r\n\r\nvar wrapper = require(\"../module-wrapper\");\r\n\r\nvar moduleName = \"loop\";\r\n\r\nfunction hasContent(parts) {\r\n  return parts.some(function (part) {\r\n    return isContent(part);\r\n  });\r\n}\r\n\r\nfunction getFirstMeaningFulPart(parsed) {\r\n  for (var i = 0, len = parsed.length; i < len; i++) {\r\n    if (parsed[i].type !== \"content\") {\r\n      return parsed[i];\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction isInsideParagraphLoop(part) {\r\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\r\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\r\n}\r\n\r\nfunction getPageBreakIfApplies(part) {\r\n  if (part.hasPageBreak) {\r\n    if (isInsideParagraphLoop(part)) {\r\n      return '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>';\r\n    }\r\n  }\r\n\r\n  return \"\";\r\n}\r\n\r\nfunction isEnclosedByParagraphs(parsed) {\r\n  if (parsed.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  return isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\r\n}\r\n\r\nfunction getOffset(chunk) {\r\n  return hasContent(chunk) ? 0 : chunk.length;\r\n}\r\n\r\nfunction addPageBreakAtEnd(subRendered) {\r\n  var found = false;\r\n  var i = subRendered.parts.length - 1;\r\n\r\n  for (var j = subRendered.parts.length - 1; i >= 0; i--) {\r\n    var p = subRendered.parts[j];\r\n\r\n    if (p === \"</w:p>\" && !found) {\r\n      found = true;\r\n      subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (!found) {\r\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\r\n  }\r\n}\r\n\r\nfunction addPageBreakAtBeginning(subRendered) {\r\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\r\n}\r\n\r\nfunction addContinuousType(parts) {\r\n  var stop = false;\r\n  var inSectPr = false;\r\n  return parts.reduce(function (result, part) {\r\n    if (stop === false && startsWith(part, \"<w:sectPr\")) {\r\n      inSectPr = true;\r\n    }\r\n\r\n    if (inSectPr) {\r\n      if (startsWith(part, \"<w:type\")) {\r\n        stop = true;\r\n      }\r\n\r\n      if (stop === false && startsWith(part, \"</w:sectPr\")) {\r\n        result.push('<w:type w:val=\"continuous\"/>');\r\n      }\r\n    }\r\n\r\n    result.push(part);\r\n    return result;\r\n  }, []);\r\n}\r\n\r\nfunction dropHeaderFooterRefs(parts) {\r\n  return parts.filter(function (text) {\r\n    if (startsWith(text, \"<w:headerReference\") || startsWith(text, \"<w:footerReference\")) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  });\r\n}\r\n\r\nfunction hasPageBreak(chunk) {\r\n  return chunk.some(function (part) {\r\n    if (part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1) {\r\n      return true;\r\n    }\r\n  });\r\n}\r\n\r\nfunction getSectPrHeaderFooterChangeCount(chunks) {\r\n  var collectSectPr = false;\r\n  var sectPrCount = 0;\r\n  chunks.forEach(function (part) {\r\n    if (part.tag === \"w:sectPr\" && part.position === \"start\") {\r\n      collectSectPr = true;\r\n    }\r\n\r\n    if (collectSectPr) {\r\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\r\n        sectPrCount++;\r\n        collectSectPr = false;\r\n      }\r\n    }\r\n\r\n    if (part.tag === \"w:sectPr\" && part.position === \"end\") {\r\n      collectSectPr = false;\r\n    }\r\n  });\r\n  return sectPrCount;\r\n}\r\n\r\nvar LoopModule = /*#__PURE__*/function () {\r\n  function LoopModule() {\r\n    _classCallCheck(this, LoopModule);\r\n\r\n    this.name = \"LoopModule\";\r\n    this.totalSectPr = 0;\r\n    this.prefix = {\r\n      start: \"#\",\r\n      end: \"/\",\r\n      dash: /^-([^\\s]+)\\s(.+)$/,\r\n      inverted: \"^\"\r\n    };\r\n  }\r\n\r\n  _createClass(LoopModule, [{\r\n    key: \"parse\",\r\n    value: function parse(placeHolderContent, _ref) {\r\n      var match = _ref.match,\r\n          getValue = _ref.getValue,\r\n          getValues = _ref.getValues;\r\n      var module = moduleName;\r\n      var type = \"placeholder\";\r\n      var _this$prefix = this.prefix,\r\n          start = _this$prefix.start,\r\n          inverted = _this$prefix.inverted,\r\n          dash = _this$prefix.dash,\r\n          end = _this$prefix.end;\r\n\r\n      if (match(start, placeHolderContent)) {\r\n        return {\r\n          type: type,\r\n          value: getValue(start, placeHolderContent),\r\n          expandTo: \"auto\",\r\n          module: module,\r\n          location: \"start\",\r\n          inverted: false\r\n        };\r\n      }\r\n\r\n      if (match(inverted, placeHolderContent)) {\r\n        return {\r\n          type: type,\r\n          value: getValue(inverted, placeHolderContent),\r\n          expandTo: \"auto\",\r\n          module: module,\r\n          location: \"start\",\r\n          inverted: true\r\n        };\r\n      }\r\n\r\n      if (match(end, placeHolderContent)) {\r\n        return {\r\n          type: type,\r\n          value: getValue(end, placeHolderContent),\r\n          module: module,\r\n          location: \"end\"\r\n        };\r\n      }\r\n\r\n      if (match(dash, placeHolderContent)) {\r\n        var _getValues = getValues(dash, placeHolderContent),\r\n            _getValues2 = _slicedToArray(_getValues, 3),\r\n            expandTo = _getValues2[1],\r\n            value = _getValues2[2];\r\n\r\n        return {\r\n          type: type,\r\n          value: value,\r\n          expandTo: expandTo,\r\n          module: module,\r\n          location: \"start\",\r\n          inverted: false\r\n        };\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"getTraits\",\r\n    value: function getTraits(traitName, parsed) {\r\n      if (traitName !== \"expandPair\") {\r\n        return;\r\n      }\r\n\r\n      return parsed.reduce(function (tags, part, offset) {\r\n        if (part.type === \"placeholder\" && part.module === moduleName && part.subparsed == null) {\r\n          tags.push({\r\n            part: part,\r\n            offset: offset\r\n          });\r\n        }\r\n\r\n        return tags;\r\n      }, []);\r\n    }\r\n  }, {\r\n    key: \"postparse\",\r\n    value: function postparse(parsed, _ref2) {\r\n      var basePart = _ref2.basePart;\r\n\r\n      if (basePart) {\r\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\r\n        basePart.sectPrIndex = this.totalSectPr;\r\n        this.totalSectPr += basePart.sectPrCount;\r\n      }\r\n\r\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\r\n        return parsed;\r\n      }\r\n\r\n      var level = 0;\r\n      var chunks = chunkBy(parsed, function (p) {\r\n        if (isParagraphStart(p)) {\r\n          level++;\r\n\r\n          if (level === 1) {\r\n            return \"start\";\r\n          }\r\n        }\r\n\r\n        if (isParagraphEnd(p)) {\r\n          level--;\r\n\r\n          if (level === 0) {\r\n            return \"end\";\r\n          }\r\n        }\r\n\r\n        return null;\r\n      });\r\n\r\n      if (chunks.length <= 2) {\r\n        return parsed;\r\n      }\r\n\r\n      var firstChunk = chunks[0];\r\n      var lastChunk = last(chunks);\r\n      var firstOffset = getOffset(firstChunk);\r\n      var lastOffset = getOffset(lastChunk);\r\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\r\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\r\n\r\n      if (firstOffset === 0 || lastOffset === 0) {\r\n        return parsed;\r\n      }\r\n\r\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\r\n    }\r\n  }, {\r\n    key: \"render\",\r\n    value: function render(part, options) {\r\n      if (part.type !== \"placeholder\" || part.module !== moduleName) {\r\n        return null;\r\n      }\r\n\r\n      var totalValue = [];\r\n      var errors = [];\r\n\r\n      function loopOver(scope, i, length) {\r\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\r\n        var subRendered = options.render(mergeObjects({}, options, {\r\n          compiled: part.subparsed,\r\n          tags: {},\r\n          scopeManager: scopeManager\r\n        }));\r\n\r\n        if (part.hasPageBreak && i === length - 1 && isInsideParagraphLoop(part)) {\r\n          addPageBreakAtEnd(subRendered);\r\n        }\r\n\r\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\r\n          return i !== 0;\r\n        });\r\n\r\n        if (isNotFirst) {\r\n          if (part.sectPrCount === 1) {\r\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\r\n          }\r\n\r\n          if (part.sectPrIndex === 0) {\r\n            // For the first sectPr in the document, add the continuous attribute (except for the first iteration)\r\n            subRendered.parts = addContinuousType(subRendered.parts);\r\n          }\r\n        }\r\n\r\n        if (part.hasPageBreakBeginning && isInsideParagraphLoop(part)) {\r\n          addPageBreakAtBeginning(subRendered);\r\n        }\r\n\r\n        totalValue = totalValue.concat(subRendered.parts);\r\n        errors = errors.concat(subRendered.errors || []);\r\n      }\r\n\r\n      var result;\r\n\r\n      try {\r\n        result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\r\n          part: part\r\n        });\r\n      } catch (e) {\r\n        errors.push(e);\r\n        return {\r\n          errors: errors\r\n        };\r\n      } // if the loop is showing empty content\r\n\r\n\r\n      if (result === false) {\r\n        return {\r\n          value: getPageBreakIfApplies(part) || \"\",\r\n          errors: errors\r\n        };\r\n      }\r\n\r\n      return {\r\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\r\n          basePart: part\r\n        })),\r\n        errors: errors\r\n      };\r\n    }\r\n  }, {\r\n    key: \"resolve\",\r\n    value: function resolve(part, options) {\r\n      if (part.type !== \"placeholder\" || part.module !== moduleName) {\r\n        return null;\r\n      }\r\n\r\n      var sm = options.scopeManager;\r\n      var promisedValue = sm.getValueAsync(part.value, {\r\n        part: part\r\n      });\r\n      var promises = [];\r\n\r\n      function loopOver(scope, i, length) {\r\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\r\n        promises.push(options.resolve({\r\n          filePath: options.filePath,\r\n          modules: options.modules,\r\n          baseNullGetter: options.baseNullGetter,\r\n          resolve: options.resolve,\r\n          compiled: part.subparsed,\r\n          tags: {},\r\n          scopeManager: scopeManager\r\n        }));\r\n      }\r\n\r\n      var errorList = [];\r\n      return promisedValue.then(function (value) {\r\n        sm.loopOverValue(value, loopOver, part.inverted);\r\n        return Promise.all(promises).then(function (r) {\r\n          return r.map(function (_ref3) {\r\n            var resolved = _ref3.resolved,\r\n                errors = _ref3.errors;\r\n\r\n            if (errors.length > 0) {\r\n              errorList.push.apply(errorList, _toConsumableArray(errors));\r\n            }\r\n\r\n            return resolved;\r\n          });\r\n        }).then(function (value) {\r\n          if (errorList.length > 0) {\r\n            throw errorList;\r\n          }\r\n\r\n          return value;\r\n        });\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return LoopModule;\r\n}();\r\n\r\nmodule.exports = function () {\r\n  return wrapper(new LoopModule());\r\n};","\r\n\r\nvar wrapper = require(\"../module-wrapper\");\r\n\r\nvar _require = require(\"../doc-utils\"),\r\n    isTextStart = _require.isTextStart,\r\n    isTextEnd = _require.isTextEnd,\r\n    endsWith = _require.endsWith,\r\n    startsWith = _require.startsWith;\r\n\r\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\r\nvar wTpreservelen = wTpreserve.length;\r\nvar wtEnd = \"</w:t>\";\r\nvar wtEndlen = wtEnd.length;\r\n\r\nfunction isWtStart(part) {\r\n  return isTextStart(part) && part.tag === \"w:t\";\r\n}\r\n\r\nfunction addXMLPreserve(chunk, index) {\r\n  var tag = chunk[index].value;\r\n\r\n  if (chunk[index + 1].value === \"</w:t>\") {\r\n    return tag;\r\n  }\r\n\r\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\r\n    return tag;\r\n  }\r\n\r\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\r\n}\r\n\r\nfunction isInsideLoop(meta, chunk) {\r\n  return meta && meta.basePart && chunk.length > 1;\r\n}\r\n\r\nvar spacePreserve = {\r\n  name: \"SpacePreserveModule\",\r\n  postparse: function postparse(postparsed, meta) {\r\n    var chunk = [],\r\n        inTextTag = false,\r\n        endLindex = 0,\r\n        lastTextTag = 0;\r\n\r\n    function isStartingPlaceHolder(part, chunk) {\r\n      return part.type === \"placeholder\" && (!part.module || part.module === \"loop\") && chunk.length > 1;\r\n    }\r\n\r\n    var result = postparsed.reduce(function (postparsed, part) {\r\n      if (isWtStart(part)) {\r\n        inTextTag = true;\r\n        lastTextTag = chunk.length;\r\n      }\r\n\r\n      if (!inTextTag) {\r\n        postparsed.push(part);\r\n        return postparsed;\r\n      }\r\n\r\n      chunk.push(part);\r\n\r\n      if (isInsideLoop(meta, chunk)) {\r\n        endLindex = meta.basePart.endLindex;\r\n        chunk[0].value = addXMLPreserve(chunk, 0);\r\n      }\r\n\r\n      if (isStartingPlaceHolder(part, chunk)) {\r\n        chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\r\n        endLindex = part.endLindex;\r\n      }\r\n\r\n      if (isTextEnd(part) && part.lIndex > endLindex) {\r\n        if (endLindex !== 0) {\r\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\r\n        }\r\n\r\n        Array.prototype.push.apply(postparsed, chunk);\r\n        chunk = [];\r\n        inTextTag = false;\r\n        endLindex = 0;\r\n        lastTextTag = 0;\r\n      }\r\n\r\n      return postparsed;\r\n    }, []);\r\n    Array.prototype.push.apply(result, chunk);\r\n    return result;\r\n  },\r\n  postrender: function postrender(parts) {\r\n    var lastNonEmpty = \"\";\r\n    var lastNonEmptyIndex = 0;\r\n    return parts.reduce(function (newParts, p, index) {\r\n      if (p === \"\") {\r\n        newParts.push(p);\r\n        return newParts;\r\n      }\r\n\r\n      if (p.indexOf('<w:t xml:space=\"preserve\"></w:t>') !== -1) {\r\n        p = p.replace(/<w:t xml:space=\"preserve\"><\\/w:t>/g, \"<w:t/>\");\r\n      }\r\n\r\n      if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\r\n        newParts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\r\n        p = p.substr(wtEndlen);\r\n      }\r\n\r\n      lastNonEmpty = p;\r\n      lastNonEmptyIndex = index;\r\n      newParts.push(p);\r\n      return newParts;\r\n    }, []);\r\n  }\r\n};\r\n\r\nmodule.exports = function () {\r\n  return wrapper(spacePreserve);\r\n};","\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar traits = require(\"../traits\");\r\n\r\nvar _require = require(\"../doc-utils\"),\r\n    isContent = _require.isContent;\r\n\r\nvar _require2 = require(\"../errors\"),\r\n    throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph;\r\n\r\nvar moduleName = \"rawxml\";\r\n\r\nvar wrapper = require(\"../module-wrapper\");\r\n\r\nfunction getInner(_ref) {\r\n  var part = _ref.part,\r\n      left = _ref.left,\r\n      right = _ref.right,\r\n      postparsed = _ref.postparsed,\r\n      index = _ref.index;\r\n  var paragraphParts = postparsed.slice(left + 1, right);\r\n  paragraphParts.forEach(function (p, i) {\r\n    if (i === index - left - 1) {\r\n      return;\r\n    }\r\n\r\n    if (isContent(p)) {\r\n      throwRawTagShouldBeOnlyTextInParagraph({\r\n        paragraphParts: paragraphParts,\r\n        part: part\r\n      });\r\n    }\r\n  });\r\n  return part;\r\n}\r\n\r\nvar RawXmlModule = /*#__PURE__*/function () {\r\n  function RawXmlModule() {\r\n    _classCallCheck(this, RawXmlModule);\r\n\r\n    this.name = \"RawXmlModule\";\r\n    this.prefix = \"@\";\r\n  }\r\n\r\n  _createClass(RawXmlModule, [{\r\n    key: \"optionsTransformer\",\r\n    value: function optionsTransformer(options, docxtemplater) {\r\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\r\n      return options;\r\n    }\r\n  }, {\r\n    key: \"parse\",\r\n    value: function parse(placeHolderContent, _ref2) {\r\n      var match = _ref2.match,\r\n          getValue = _ref2.getValue;\r\n      var type = \"placeholder\";\r\n\r\n      if (match(this.prefix, placeHolderContent)) {\r\n        return {\r\n          type: type,\r\n          value: getValue(this.prefix, placeHolderContent),\r\n          module: moduleName\r\n        };\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"postparse\",\r\n    value: function postparse(postparsed) {\r\n      return traits.expandToOne(postparsed, {\r\n        moduleName: moduleName,\r\n        getInner: getInner,\r\n        expandTo: this.fileTypeConfig.tagRawXml,\r\n        error: {\r\n          message: \"Raw tag not in paragraph\",\r\n          id: \"raw_tag_outerxml_invalid\",\r\n          explanation: function explanation(part) {\r\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }, {\r\n    key: \"render\",\r\n    value: function render(part, options) {\r\n      if (part.module !== moduleName) {\r\n        return null;\r\n      }\r\n\r\n      var value;\r\n      var errors = [];\r\n\r\n      try {\r\n        value = options.scopeManager.getValue(part.value, {\r\n          part: part\r\n        });\r\n\r\n        if (value == null) {\r\n          value = options.nullGetter(part);\r\n        }\r\n      } catch (e) {\r\n        errors.push(e);\r\n        return {\r\n          errors: errors\r\n        };\r\n      }\r\n\r\n      if (!value) {\r\n        return {\r\n          value: \"\"\r\n        };\r\n      }\r\n\r\n      return {\r\n        value: value\r\n      };\r\n    }\r\n  }, {\r\n    key: \"resolve\",\r\n    value: function resolve(part, options) {\r\n      if (part.type !== \"placeholder\" || part.module !== moduleName) {\r\n        return null;\r\n      }\r\n\r\n      return options.scopeManager.getValueAsync(part.value, {\r\n        part: part\r\n      }).then(function (value) {\r\n        if (value == null) {\r\n          return options.nullGetter(part);\r\n        }\r\n\r\n        return value;\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return RawXmlModule;\r\n}();\r\n\r\nmodule.exports = function () {\r\n  return wrapper(new RawXmlModule());\r\n};","\r\n\r\nvar traitName = \"expandPair\";\r\n\r\nvar mergeSort = require(\"../mergesort\");\r\n\r\nvar _require = require(\"../doc-utils\"),\r\n    getLeft = _require.getLeft,\r\n    getRight = _require.getRight;\r\n\r\nvar wrapper = require(\"../module-wrapper\");\r\n\r\nvar _require2 = require(\"../traits\"),\r\n    getExpandToDefault = _require2.getExpandToDefault;\r\n\r\nvar _require3 = require(\"../errors\"),\r\n    getUnmatchedLoopException = _require3.getUnmatchedLoopException,\r\n    getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\r\n    throwLocationInvalid = _require3.throwLocationInvalid,\r\n    getUnbalancedLoopException = _require3.getUnbalancedLoopException;\r\n\r\nfunction getOpenCountChange(part) {\r\n  switch (part.location) {\r\n    case \"start\":\r\n      return 1;\r\n\r\n    case \"end\":\r\n      return -1;\r\n\r\n    default:\r\n      throwLocationInvalid(part);\r\n  }\r\n}\r\n\r\nfunction match(start, end) {\r\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\r\n}\r\n\r\nfunction transformer(traits) {\r\n  var i = 0;\r\n  var errors = [];\r\n\r\n  while (i < traits.length) {\r\n    var part = traits[i].part;\r\n\r\n    if (part.location === \"end\") {\r\n      if (i === 0) {\r\n        traits.splice(0, 1);\r\n        errors.push(getUnmatchedLoopException(part));\r\n        return {\r\n          traits: traits,\r\n          errors: errors\r\n        };\r\n      }\r\n\r\n      var endIndex = i;\r\n      var startIndex = i - 1;\r\n      var offseter = 1;\r\n\r\n      if (match(traits[startIndex], traits[endIndex])) {\r\n        traits.splice(endIndex, 1);\r\n        traits.splice(startIndex, 1);\r\n        return {\r\n          errors: errors,\r\n          traits: traits\r\n        };\r\n      }\r\n\r\n      while (offseter < 50) {\r\n        var startCandidate = traits[startIndex - offseter];\r\n        var endCandidate = traits[endIndex + offseter];\r\n\r\n        if (match(startCandidate, traits[endIndex])) {\r\n          traits.splice(endIndex, 1);\r\n          traits.splice(startIndex - offseter, 1);\r\n          return {\r\n            errors: errors,\r\n            traits: traits\r\n          };\r\n        }\r\n\r\n        if (match(traits[startIndex], endCandidate)) {\r\n          traits.splice(endIndex + offseter, 1);\r\n          traits.splice(startIndex, 1);\r\n          return {\r\n            errors: errors,\r\n            traits: traits\r\n          };\r\n        }\r\n\r\n        offseter++;\r\n      }\r\n\r\n      errors.push(getClosingTagNotMatchOpeningTag({\r\n        tags: [traits[startIndex].part, traits[endIndex].part]\r\n      }));\r\n      traits.splice(endIndex, 1);\r\n      traits.splice(startIndex, 1);\r\n      return {\r\n        traits: traits,\r\n        errors: errors\r\n      };\r\n    }\r\n\r\n    if (traits[i] == null) {\r\n      break;\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  traits.forEach(function (_ref) {\r\n    var part = _ref.part;\r\n    errors.push(getUnmatchedLoopException(part));\r\n  });\r\n  return {\r\n    traits: [],\r\n    errors: errors\r\n  };\r\n}\r\n\r\nfunction getPairs(traits) {\r\n  var levelTraits = {};\r\n  var errors = [];\r\n  var pairs = [];\r\n  var countOpen = 0;\r\n  var transformedTraits = [];\r\n\r\n  for (var i = 0; i < traits.length; i++) {\r\n    var currentTrait = traits[i];\r\n    var part = currentTrait.part;\r\n    var change = getOpenCountChange(currentTrait.part);\r\n    countOpen += change;\r\n    var level = void 0;\r\n\r\n    if (change === 1) {\r\n      level = countOpen - 1;\r\n    } else {\r\n      level = countOpen;\r\n    }\r\n\r\n    transformedTraits.push({\r\n      level: level,\r\n      part: part\r\n    });\r\n  }\r\n\r\n  while (transformedTraits.length > 0) {\r\n    var result = transformer(transformedTraits);\r\n    errors = errors.concat(result.errors);\r\n    transformedTraits = result.traits;\r\n  }\r\n\r\n  if (errors.length > 0) {\r\n    return {\r\n      pairs: pairs,\r\n      errors: errors\r\n    };\r\n  }\r\n\r\n  countOpen = 0;\r\n\r\n  for (var _i = 0; _i < traits.length; _i++) {\r\n    var _currentTrait = traits[_i];\r\n    var _part = _currentTrait.part;\r\n\r\n    var _change = getOpenCountChange(_part);\r\n\r\n    countOpen += _change;\r\n\r\n    if (_change === 1) {\r\n      levelTraits[countOpen] = _currentTrait;\r\n    } else {\r\n      var startTrait = levelTraits[countOpen + 1];\r\n\r\n      if (countOpen === 0) {\r\n        pairs = pairs.concat([[startTrait, _currentTrait]]);\r\n      }\r\n    }\r\n\r\n    countOpen = countOpen >= 0 ? countOpen : 0;\r\n  }\r\n\r\n  return {\r\n    pairs: pairs,\r\n    errors: errors\r\n  };\r\n}\r\n\r\nvar expandPairTrait = {\r\n  name: \"ExpandPairTrait\",\r\n  optionsTransformer: function optionsTransformer(options, docxtemplater) {\r\n    this.expandTags = docxtemplater.fileTypeConfig.expandTags.concat(docxtemplater.options.paragraphLoop ? docxtemplater.fileTypeConfig.onParagraphLoop : []);\r\n    return options;\r\n  },\r\n  postparse: function postparse(postparsed, _ref2) {\r\n    var _this = this;\r\n\r\n    var getTraits = _ref2.getTraits,\r\n        postparse = _ref2.postparse;\r\n    var traits = getTraits(traitName, postparsed);\r\n    traits = traits.map(function (trait) {\r\n      return trait || [];\r\n    });\r\n    traits = mergeSort(traits);\r\n\r\n    var _getPairs = getPairs(traits),\r\n        pairs = _getPairs.pairs,\r\n        errors = _getPairs.errors;\r\n\r\n    var lastRight = 0;\r\n    var lastPair = null;\r\n    var expandedPairs = pairs.map(function (pair) {\r\n      var expandTo = pair[0].part.expandTo;\r\n\r\n      if (expandTo === \"auto\") {\r\n        var result = getExpandToDefault(postparsed, pair, _this.expandTags);\r\n\r\n        if (result.error) {\r\n          errors.push(result.error);\r\n        }\r\n\r\n        expandTo = result.value;\r\n      }\r\n\r\n      if (!expandTo) {\r\n        var _left = pair[0].offset;\r\n        var _right = pair[1].offset;\r\n\r\n        if (_left < lastRight) {\r\n          errors.push(getUnbalancedLoopException(pair, lastPair));\r\n        }\r\n\r\n        lastPair = pair;\r\n        lastRight = _right;\r\n        return [_left, _right];\r\n      }\r\n\r\n      var left, right;\r\n\r\n      try {\r\n        left = getLeft(postparsed, expandTo, pair[0].offset);\r\n      } catch (e) {\r\n        errors.push(e);\r\n      }\r\n\r\n      try {\r\n        right = getRight(postparsed, expandTo, pair[1].offset);\r\n      } catch (e) {\r\n        errors.push(e);\r\n      }\r\n\r\n      if (left < lastRight) {\r\n        errors.push(getUnbalancedLoopException(pair, lastPair));\r\n      }\r\n\r\n      lastRight = right;\r\n      lastPair = pair;\r\n      return [left, right];\r\n    });\r\n\r\n    if (errors.length > 0) {\r\n      return {\r\n        postparsed: postparsed,\r\n        errors: errors\r\n      };\r\n    }\r\n\r\n    var currentPairIndex = 0;\r\n    var innerParts;\r\n    var newParsed = postparsed.reduce(function (newParsed, part, i) {\r\n      var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\r\n      var pair = pairs[currentPairIndex];\r\n      var expandedPair = expandedPairs[currentPairIndex];\r\n\r\n      if (!inPair) {\r\n        newParsed.push(part);\r\n        return newParsed;\r\n      }\r\n\r\n      if (expandedPair[0] === i) {\r\n        innerParts = [];\r\n      }\r\n\r\n      if (pair[0].offset !== i && pair[1].offset !== i) {\r\n        innerParts.push(part);\r\n      }\r\n\r\n      if (expandedPair[1] === i) {\r\n        var basePart = postparsed[pair[0].offset];\r\n        basePart.subparsed = postparse(innerParts, {\r\n          basePart: basePart\r\n        });\r\n        delete basePart.location;\r\n        delete basePart.expandTo;\r\n        newParsed.push(basePart);\r\n        currentPairIndex++;\r\n      }\r\n\r\n      return newParsed;\r\n    }, []);\r\n    return {\r\n      postparsed: newParsed,\r\n      errors: errors\r\n    };\r\n  }\r\n};\r\n\r\nmodule.exports = function () {\r\n  return wrapper(expandPairTrait);\r\n};","\r\n\r\nfunction getMinFromArrays(arrays, state) {\r\n  var minIndex = -1;\r\n\r\n  for (var i = 0, l = arrays.length; i < l; i++) {\r\n    if (state[i] >= arrays[i].length) {\r\n      continue;\r\n    }\r\n\r\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\r\n      minIndex = i;\r\n    }\r\n  }\r\n\r\n  if (minIndex === -1) {\r\n    throw new Error(\"minIndex negative\");\r\n  }\r\n\r\n  return minIndex;\r\n}\r\n\r\nmodule.exports = function (arrays) {\r\n  var totalLength = arrays.reduce(function (sum, array) {\r\n    return sum + array.length;\r\n  }, 0);\r\n  arrays = arrays.filter(function (array) {\r\n    return array.length > 0;\r\n  });\r\n  var resultArray = new Array(totalLength);\r\n  var state = arrays.map(function () {\r\n    return 0;\r\n  });\r\n  var i = 0;\r\n\r\n  while (i <= totalLength - 1) {\r\n    var arrayIndex = getMinFromArrays(arrays, state);\r\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\r\n    state[arrayIndex]++;\r\n    i++;\r\n  }\r\n\r\n  return resultArray;\r\n};","\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar wrapper = require(\"../module-wrapper\");\r\n\r\nvar _require = require(\"../errors\"),\r\n    getScopeCompilationError = _require.getScopeCompilationError;\r\n\r\nvar _require2 = require(\"../doc-utils\"),\r\n    utf8ToWord = _require2.utf8ToWord,\r\n    hasCorruptCharacters = _require2.hasCorruptCharacters;\r\n\r\nvar _require3 = require(\"../errors\"),\r\n    getCorruptCharactersException = _require3.getCorruptCharactersException;\r\n\r\nvar ftprefix = {\r\n  docx: \"w\",\r\n  pptx: \"a\"\r\n};\r\n\r\nvar Render = /*#__PURE__*/function () {\r\n  function Render() {\r\n    _classCallCheck(this, Render);\r\n\r\n    this.name = \"Render\";\r\n    this.recordRun = false;\r\n    this.recordedRun = [];\r\n  }\r\n\r\n  _createClass(Render, [{\r\n    key: \"set\",\r\n    value: function set(obj) {\r\n      if (obj.compiled) {\r\n        this.compiled = obj.compiled;\r\n      }\r\n\r\n      if (obj.data != null) {\r\n        this.data = obj.data;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"getRenderedMap\",\r\n    value: function getRenderedMap(mapper) {\r\n      var _this = this;\r\n\r\n      return Object.keys(this.compiled).reduce(function (mapper, from) {\r\n        mapper[from] = {\r\n          from: from,\r\n          data: _this.data\r\n        };\r\n        return mapper;\r\n      }, mapper);\r\n    }\r\n  }, {\r\n    key: \"optionsTransformer\",\r\n    value: function optionsTransformer(options, docxtemplater) {\r\n      this.parser = docxtemplater.parser;\r\n      this.fileType = docxtemplater.fileType;\r\n      return options;\r\n    }\r\n  }, {\r\n    key: \"postparse\",\r\n    value: function postparse(postparsed, options) {\r\n      var _this2 = this;\r\n\r\n      var errors = [];\r\n      postparsed.forEach(function (p) {\r\n        if (p.type === \"placeholder\") {\r\n          var tag = p.value;\r\n\r\n          try {\r\n            options.cachedParsers[p.lIndex] = _this2.parser(tag, {\r\n              tag: p\r\n            });\r\n          } catch (rootError) {\r\n            errors.push(getScopeCompilationError({\r\n              tag: tag,\r\n              rootError: rootError,\r\n              offset: p.offset\r\n            }));\r\n          }\r\n        }\r\n      });\r\n      return {\r\n        postparsed: postparsed,\r\n        errors: errors\r\n      };\r\n    }\r\n  }, {\r\n    key: \"recordRuns\",\r\n    value: function recordRuns(part) {\r\n      if (part.tag === \"\".concat(ftprefix[this.fileType], \":r\")) {\r\n        this.recordRun = false;\r\n        this.recordedRun = [];\r\n      } else if (part.tag === \"\".concat(ftprefix[this.fileType], \":rPr\")) {\r\n        if (part.position === \"start\") {\r\n          this.recordRun = true;\r\n          this.recordedRun = [part.value];\r\n        }\r\n\r\n        if (part.position === \"end\") {\r\n          this.recordedRun.push(part.value);\r\n          this.recordRun = false;\r\n        }\r\n      } else if (this.recordRun) {\r\n        this.recordedRun.push(part.value);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"render\",\r\n    value: function render(part, _ref) {\r\n      var scopeManager = _ref.scopeManager,\r\n          linebreaks = _ref.linebreaks,\r\n          nullGetter = _ref.nullGetter;\r\n\r\n      if (linebreaks) {\r\n        this.recordRuns(part);\r\n      }\r\n\r\n      if (part.type !== \"placeholder\" || part.module) {\r\n        return;\r\n      }\r\n\r\n      var value;\r\n\r\n      try {\r\n        value = scopeManager.getValue(part.value, {\r\n          part: part\r\n        });\r\n      } catch (e) {\r\n        return {\r\n          errors: [e]\r\n        };\r\n      }\r\n\r\n      if (value == null) {\r\n        value = nullGetter(part);\r\n      }\r\n\r\n      if (hasCorruptCharacters(value)) {\r\n        return {\r\n          errors: [getCorruptCharactersException({\r\n            tag: part.value,\r\n            value: value,\r\n            offset: part.offset\r\n          })]\r\n        };\r\n      }\r\n\r\n      if (typeof value !== \"string\") {\r\n        value = value.toString();\r\n      }\r\n\r\n      if (linebreaks) {\r\n        return this.renderLineBreaks(value);\r\n      }\r\n\r\n      return {\r\n        value: utf8ToWord(value)\r\n      };\r\n    }\r\n  }, {\r\n    key: \"renderLineBreaks\",\r\n    value: function renderLineBreaks(value) {\r\n      var p = ftprefix[this.fileType];\r\n      var br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\r\n      var lines = value.split(\"\\n\");\r\n      var runprops = this.recordedRun.join(\"\");\r\n      return {\r\n        value: lines.map(function (line) {\r\n          return utf8ToWord(line);\r\n        }).join(\"</\".concat(p, \":t></\").concat(p, \":r>\").concat(br, \"<\").concat(p, \":r>\").concat(runprops, \"<\").concat(p, \":t\").concat(this.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"))\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return Render;\r\n}();\r\n\r\nmodule.exports = function () {\r\n  return wrapper(new Render());\r\n};"]}